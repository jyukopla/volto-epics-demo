# pylama:ignore=D100,D101,D106,C0114,C0115,C0302,R0903,W0107
# generated by datamodel-codegen:
#   filename:  camunda.json
#   timestamp: 2021-01-08T08:52:12+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from pydantic import BaseModel
from pydantic import conint
from pydantic import Extra
from pydantic import Field
from typing import Any
from typing import Dict
from typing import List
from typing import Optional


class VariableValueDto(BaseModel):
    value: Optional[Any] = Field(
        None,
        description="The variable's value. Value differs depending on the variable's type and on the deserializeValues parameter.",
    )
    type: Optional[str] = Field(None, description="The value type of the variable.")
    valueInfo: Optional[Dict[str, str]] = Field(
        None,
        description="A JSON object containing additional, value-type-dependent properties.\nFor serialized variables of type Object, the following properties can be provided:\n\n* `objectTypeName`: A string representation of the object's type name.\n* `serializationDataFormat`: The serialization format used to store the variable.\n\nFor serialized variables of type File, the following properties can be provided:\n\n* `filename`: The name of the file. This is not the variable name but the name that will be used when downloading the file again.\n* `mimetype`: The MIME type of the file that is being uploaded.\n* `encoding`: The encoding of the file that is being uploaded.",
    )


class AbstractSetRemovalTimeDto(BaseModel):
    absoluteRemovalTime: Optional[datetime] = Field(
        None,
        description="The date for which the instances shall be removed. Value may not be `null`.\n\n**Note:** Cannot be set in conjunction with `clearedRemovalTime` or `calculatedRemovalTime`.",
    )
    clearedRemovalTime: Optional[bool] = Field(
        None,
        description="Sets the removal time to `null`. Value may only be `true`, as `false` is the default behavior.\n\n**Note:** Cannot be set in conjunction with `absoluteRemovalTime` or `calculatedRemovalTime`.",
    )
    calculatedRemovalTime: Optional[bool] = Field(
        None,
        description="The removal time is calculated based on the engine's configuration settings. Value may only be `true`, as `false` is the default behavior.\n\n**Note:** Cannot be set in conjunction with `absoluteRemovalTime` or `clearedRemovalTime`.",
    )


class ActivityInstanceIncidentDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the incident.")
    parentActivityInstanceId: Optional[str] = Field(
        None, description="The activity id in which the incident happened."
    )


class AtomLink(BaseModel):
    rel: Optional[str] = Field(
        None, description="The relation of the link to the object that belongs to."
    )
    href: Optional[str] = Field(None, description="The url of the link.")
    method: Optional[str] = Field(None, description="The http method.")


class AuthenticationResult(BaseModel):
    authenticatedUser: Optional[str] = Field(
        None, description="An id of authenticated user."
    )
    isAuthenticated: Optional[bool] = Field(
        None, description="A flag indicating if user is authenticated."
    )
    tenants: Optional[List[str]] = Field(None, description="Will be null.")
    groups: Optional[List[str]] = Field(None, description="Will be null.")


class BasicUserCredentialsDto(BaseModel):
    username: Optional[str] = Field(None, description="The username of a user.")
    password: Optional[str] = Field(None, description="A password of a user.")


class BatchDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the batch.")
    type: Optional[str] = Field(
        None,
        description="The type of the batch.\nSee the [User Guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/batch/#creating-a-batch)\nfor more information about batch types.",
    )
    totalJobs: Optional[int] = Field(
        None,
        description="The total jobs of a batch is the number of batch execution jobs required to complete the batch.",
    )
    jobsCreated: Optional[int] = Field(
        None,
        description="The number of batch execution jobs already created by the seed job.",
    )
    batchJobsPerSeed: Optional[int] = Field(
        None,
        description="The number of batch execution jobs created per seed job invocation.\nThe batch seed job is invoked until it has created all batch execution jobs required by the batch\n(see `totalJobs` property).",
    )
    invocationsPerBatchJob: Optional[int] = Field(
        None,
        description="Every batch execution job invokes the command executed by the batch `invocationsPerBatchJob` times.\nE.g., for a process instance migration batch this specifies the number of process instances which are migrated per batch execution job.",
    )
    seedJobDefinitionId: Optional[str] = Field(
        None, description="The job definition id for the seed jobs of this batch."
    )
    monitorJobDefinitionId: Optional[str] = Field(
        None, description="The job definition id for the monitor jobs of this batch."
    )
    batchJobDefinitionId: Optional[str] = Field(
        None,
        description="The job definition id for the batch execution jobs of this batch.",
    )
    suspended: Optional[bool] = Field(
        None, description="Indicates whether this batch is suspended or not."
    )
    tenantId: Optional[str] = Field(None, description="The tenant id of the batch.")
    createUserId: Optional[str] = Field(
        None, description="The id of the user that created the batch."
    )


class BatchStatisticsDto(BatchDto):
    remainingJobs: Optional[int] = Field(
        None,
        description="The number of remaining batch execution jobs. This does include failed batch execution jobs and\nbatch execution jobs which still have to be created by the seed job.",
    )
    completedJobs: Optional[int] = Field(
        None,
        description="The number of completed batch execution jobs. This does include aborted/deleted batch execution jobs.",
    )
    failedJobs: Optional[int] = Field(
        None,
        description="The number of failed batch execution jobs. This does not include aborted or deleted batch execution jobs.",
    )


class CaseDefinitionDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the case definition")
    key: Optional[str] = Field(
        None,
        description="The key of the case definition, i.e., the id of the CMMN 2.0 XML case definition.",
    )
    category: Optional[str] = Field(
        None, description="The category of the case definition."
    )
    name: Optional[str] = Field(None, description="The name of the case definition.")
    version: Optional[int] = Field(
        None,
        description="The version of the case definition that the engine assigned to it.",
    )
    resource: Optional[str] = Field(
        None, description="The file name of the case definition."
    )
    deploymentId: Optional[str] = Field(
        None, description="The deployment id of the case definition."
    )
    tenantId: Optional[str] = Field(
        None, description="The tenant id of the case definition."
    )
    historyTimeToLive: Optional[conint(ge=0)] = Field(  # type: ignore
        None,
        description="History time to live value of the case definition.\nIs used within [History cleanup](https://docs.camunda.org/manual/latest/user-guide/process-engine/history/#history-cleanup).",
    )


class CompleteTaskDto(BaseModel):
    variables: Optional[Dict[str, VariableValueDto]] = Field(
        None, description="A JSON object containing variable key-value pairs."
    )
    withVariablesInReturn: Optional[bool] = Field(
        False,
        description="Indicates whether the response should contain the process variables or not. The\ndefault is `false` with a response code of `204`. If set to `true` the response\ncontains the process variables and has a response code of `200`. If the task is not\nassociated with a process instance (e.g. if it's part of a case instance) no\nvariables will be returned.",
    )


class CorrelationKeys(BaseModel):
    pass


class LocalCorrelationKeys(BaseModel):
    pass


class CorrelationMessageDto(BaseModel):
    messageName: Optional[str] = Field(
        None, description="The name of the message to deliver."
    )
    businessKey: Optional[str] = Field(
        None,
        description="Used for correlation of process instances that wait for incoming messages.\nWill only correlate to executions that belong to a process instance with the provided business key.",
    )
    tenantId: Optional[str] = Field(
        None,
        description="Used to correlate the message for a tenant with the given id.\nWill only correlate to executions and process definitions which belong to the tenant.\nMust not be supplied in conjunction with a `withoutTenantId`.",
    )
    withoutTenantId: Optional[bool] = Field(
        False,
        description="A Boolean value that indicates whether the message should only be correlated to executions\nand process definitions which belong to no tenant or not. Value may only be `true`, as `false`\nis the default behavior.\nMust not be supplied in conjunction with a `tenantId`.",
    )
    processInstanceId: Optional[str] = Field(
        None,
        description="Used to correlate the message to the process instance with the given id.",
    )
    correlationKeys: Optional[Dict[str, VariableValueDto]] = Field(
        None,
        description="Used for correlation of process instances that wait for incoming messages.\nHas to be a JSON object containing key-value pairs that are matched against process instance variables\nduring correlation. Each key is a variable name and each value a JSON variable value object with the\nfollowing properties.",
    )
    localCorrelationKeys: Optional[Dict[str, VariableValueDto]] = Field(
        None,
        description="Local variables used for correlation of executions (process instances) that wait for incoming messages.\nHas to be a JSON object containing key-value pairs that are matched against local variables during correlation.\nEach key is a variable name and each value a JSON variable value object with the following properties.",
    )
    processVariables: Optional[Dict[str, VariableValueDto]] = Field(
        None,
        description="A map of variables that is injected into the triggered execution or process instance after the message\nhas been delivered. Each key is a variable name and each value a JSON variable value object with\nthe following properties.",
    )
    processVariablesLocal: Optional[Dict[str, VariableValueDto]] = Field(
        None,
        description="A map of local variables that is injected into the triggered execution or process instance after the\nmessage has been delivered. Each key is a variable name and each value a JSON variable value object\nwith the following properties.",
    )
    all: Optional[bool] = Field(
        False,
        description="A Boolean value that indicates whether the message should be correlated to exactly one entity or multiple entities.\nIf the value is set to `false`, the message will be correlated to exactly one entity (execution or process definition).\nIf the value is set to `true`, the message will be correlated to multiple executions and a process definition that\ncan be instantiated by this message in one go.",
    )
    resultEnabled: Optional[bool] = Field(
        False,
        description="A Boolean value that indicates whether the result of the correlation should be returned or not.\nIf this property is set to `true`, there will be returned a list of message correlation result objects. Depending on the\nall property, there will be either one ore more returned results in the list.\n\nThe default value is `false`, which means no result will be returned.",
    )
    variablesInResultEnabled: Optional[bool] = Field(
        False,
        description="A Boolean value that indicates whether the result of the correlation should contain process variables or not.\nThe parameter resultEnabled should be set to `true` in order to use this it.\n\nThe default value is `false`, which means the variables will not be returned.",
    )


class CountResultDto(BaseModel):
    count: Optional[int] = Field(None, description="The number of matching instances.")


class DecisionDefinitionDiagramDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the decision definition.")
    dmnXml: Optional[str] = Field(
        None,
        description="An escaped XML string containing the XML that this decision definition was deployed with.\nCarriage returns, line feeds and quotation marks are escaped.",
    )


class DecisionDefinitionDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the decision definition")
    key: Optional[str] = Field(
        None,
        description="The key of the decision definition, i.e., the id of the DMN 1.0 XML decision definition.",
    )
    category: Optional[str] = Field(
        None, description="The category of the decision definition."
    )
    name: Optional[str] = Field(
        None, description="The name of the decision definition."
    )
    version: Optional[int] = Field(
        None,
        description="The version of the decision definition that the engine assigned to it.",
    )
    resource: Optional[str] = Field(
        None, description="The file name of the decision definition."
    )
    deploymentId: Optional[str] = Field(
        None, description="The deployment id of the decision definition."
    )
    tenantId: Optional[str] = Field(
        None, description="The tenant id of the decision definition."
    )
    decisionRequirementsDefinitionId: Optional[str] = Field(
        None,
        description="The id of the decision requirements definition this decision definition belongs to.",
    )
    decisionRequirementsDefinitionKey: Optional[str] = Field(
        None,
        description="The key of the decision requirements definition this decision definition belongs to.",
    )
    historyTimeToLive: Optional[conint(ge=0)] = Field(  # type: ignore
        None,
        description="History time to live value of the decision definition.\nIs used within [History cleanup](https://docs.camunda.org/manual/latest/user-guide/process-engine/history/#history-cleanup).",
    )
    versionTag: Optional[str] = Field(
        None, description="The version tag of the decision definition."
    )


class DecisionRequirementsDefinitionDto(BaseModel):
    id: Optional[str] = Field(
        None, description="The id of the decision requirements definition"
    )
    key: Optional[str] = Field(
        None,
        description="The key of the decision requirements definition, i.e., the id of the DMN 1.0 XML decision definition.",
    )
    name: Optional[str] = Field(
        None, description="The name of the decision requirements definition."
    )
    category: Optional[str] = Field(
        None, description="The category of the decision requirements definition."
    )
    version: Optional[int] = Field(
        None,
        description="The version of the decision requirements definition that the engine assigned to it.",
    )
    resource: Optional[str] = Field(
        None, description="The file name of the decision requirements definition."
    )
    deploymentId: Optional[str] = Field(
        None, description="The deployment id of the decision requirements definition."
    )
    tenantId: Optional[str] = Field(
        None, description="The tenant id of the decisionrequirements definition."
    )


class DeploymentResourceDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the deployment resource.")
    name: Optional[str] = Field(None, description="The name of the deployment resource")
    deploymentId: Optional[str] = Field(None, description="The id of the deployment.")


class DeployedProcessDefinitions(BaseModel):
    pass


class DeployedDecisionDefinitions(BaseModel):
    pass


class DeployedDecisionRequirementsDefinitions(BaseModel):
    pass


class DeployedCaseDefinitions(BaseModel):
    pass


class PeriodUnit(str, Enum):
    MONTH = "MONTH"
    QUARTER = "QUARTER"


class DurationReportResultDto(BaseModel):
    period: Optional[int] = Field(
        None,
        description="Specifies a timespan within a year.\n**Note:** The period must be interpreted in conjunction with the returned `periodUnit`.",
    )
    periodUnit: Optional[PeriodUnit] = Field(
        None,
        description="The unit of the given period. Possible values are `MONTH` and `QUARTER`.",
    )
    minimum: Optional[int] = Field(
        None,
        description="The smallest duration in milliseconds of all completed process instances which were started in the given period.",
    )
    maximum: Optional[int] = Field(
        None,
        description="The greatest duration in milliseconds of all completed process instances which were started in the given period.",
    )
    average: Optional[int] = Field(
        None,
        description="The average duration in milliseconds of all completed process instances which were started in the given period.",
    )


class EvaluateDecisionDto(BaseModel):
    variables: Optional[Dict[str, VariableValueDto]] = Field(None, description="")


class EvaluationConditionDto(BaseModel):
    variables: Optional[Dict[str, VariableValueDto]] = Field(
        None,
        description="A map of variables which are used for evaluation of the conditions and are injected into the process instances which have been triggered.\nEach key is a variable name and each value a JSON variable value object with the following properties.",
    )
    businessKey: Optional[str] = Field(
        None,
        description="Used for the process instances that have been triggered after the evaluation.",
    )
    tenantId: Optional[str] = Field(
        None,
        description="Used to evaluate a condition for a tenant with the given id.\nWill only evaluate conditions of process definitions which belong to the tenant.",
    )
    withoutTenantId: Optional[bool] = Field(
        None,
        description="A Boolean value that indicates whether the conditions should only be evaluated of process definitions which belong to no tenant or not.\nValue may only be true, as false is the default behavior.",
    )
    processDefinitionId: Optional[str] = Field(
        None,
        description="Used to evaluate conditions of the process definition with the given id.",
    )


class EventSubscriptionDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the event subscription.")
    eventType: Optional[str] = Field(
        None, description="The type of the event subscription."
    )
    eventName: Optional[str] = Field(
        None,
        description="The name of the event this subscription belongs to as defined in the process model.",
    )
    executionId: Optional[str] = Field(
        None, description="The execution that is subscribed on the referenced event."
    )
    processInstanceId: Optional[str] = Field(
        None, description="The process instance this subscription belongs to."
    )
    activityId: Optional[str] = Field(
        None,
        description="The identifier of the activity that this event subscription belongs to.\nThis could for example be the id of a receive task.",
    )
    createdDate: Optional[datetime] = Field(
        None, description="The time this event subscription was created."
    )
    tenantId: Optional[str] = Field(
        None,
        description="The id of the tenant this event subscription belongs to.\nCan be `null` if the subscription belongs to no single tenant.",
    )


class EventType(str, Enum):
    message = "message"
    signal = "signal"
    compensate = "compensate"
    conditional = "conditional"


class SortBy(str, Enum):
    created = "created"
    tenantId = "tenantId"


class SortOrder(str, Enum):
    asc = "asc"
    desc = "desc"


class SortingItem(BaseModel):
    sortBy: Optional[SortBy7] = Field(
        None,
        description="Sort the results lexicographically by a given criterion.\nMust be used in conjunction with the sortOrder parameter.",
    )
    sortOrder: Optional[SortOrder7] = Field(
        None,
        description="Sort the results in a given order. Values may be `asc` for ascending order or `desc` for\ndescending order. Must be used in conjunction with the sortBy parameter.",
    )
    parameters: Optional[SortTaskQueryParametersDto] = None


class EventSubscriptionQueryDto(BaseModel):
    eventSubscriptionId: Optional[str] = Field(
        None, description="The id of the event subscription."
    )
    eventName: Optional[str] = Field(
        None,
        description="The name of the event this subscription belongs to as defined in the process model.",
    )
    eventType: Optional[EventType] = Field(
        None, description="The type of the event subscription."
    )
    executionId: Optional[str] = Field(
        None, description="The execution that is subscribed on the referenced event."
    )
    processInstanceId: Optional[str] = Field(
        None, description="The process instance this subscription belongs to."
    )
    activityId: Optional[str] = Field(
        None,
        description="The identifier of the activity that this event subscription belongs to.\nThis could for example be the id of a receive task.",
    )
    tenantIdIn: Optional[List[str]] = Field(
        None,
        description="Filter by a comma-separated list of tenant ids.\nOnly select subscriptions that belong to one of the given tenant ids.",
    )
    withoutTenantId: Optional[bool] = Field(
        None,
        description="Only select subscriptions which have no tenant id.\nValue may only be `true`, as `false` is the default behavior.",
    )
    includeEventSubscriptionsWithoutTenantId: Optional[bool] = Field(
        None,
        description="Select event subscriptions which have no tenant id.\nCan be used in combination with tenantIdIn parameter.\nValue may only be `true`, as `false` is the default behavior.",
    )
    sorting: Optional[List[SortingItem]] = Field(
        None, description="Apply sorting of the result"
    )


class ExceptionDto(BaseModel):
    type: Optional[str] = Field(
        None, description="An exception class indicating the occurred error."
    )
    message: Optional[str] = Field(None, description="A detailed message of the error.")


class ExecutionDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the Execution.")
    processInstanceId: Optional[str] = Field(
        None,
        description="The id of the root of the execution tree representing the process instance.",
    )
    ended: Optional[bool] = Field(
        None, description="Indicates if the execution is ended."
    )
    tenantId: Optional[str] = Field(
        None,
        description="The id of the tenant this execution belongs to. Can be `null`\nif the execution belongs to no single tenant.",
    )


class ExternalTaskDto(BaseModel):
    activityId: Optional[str] = Field(
        None, description="The id of the activity that this external task belongs to."
    )
    activityInstanceId: Optional[str] = Field(
        None,
        description="The id of the activity instance that the external task belongs to.",
    )
    errorMessage: Optional[str] = Field(
        None,
        description="The full error message submitted with the latest reported failure executing this task; `null` if no\nfailure was reported previously or if no error message was submitted",
    )
    executionId: Optional[str] = Field(
        None, description="The id of the execution that the external task belongs to."
    )
    id: Optional[str] = Field(None, description="The id of the external task.")
    lockExpirationTime: Optional[datetime] = Field(
        None,
        description="The date that the task's most recent lock expires or has expired.",
    )
    processDefinitionId: Optional[str] = Field(
        None,
        description="The id of the process definition the external task is defined in.",
    )
    processDefinitionKey: Optional[str] = Field(
        None,
        description="The key of the process definition the external task is defined in.",
    )
    processDefinitionVersionTag: Optional[str] = Field(
        None,
        description="The version tag of the process definition the external task is defined in.",
    )
    processInstanceId: Optional[str] = Field(
        None, description="The id of the process instance the external task belongs to."
    )
    tenantId: Optional[str] = Field(
        None, description="The id of the tenant the external task belongs to."
    )
    retries: Optional[int] = Field(
        None, description="The number of retries the task currently has left."
    )
    suspended: Optional[bool] = Field(
        None,
        description="A flag indicating whether the external task is suspended or not.",
    )
    workerId: Optional[str] = Field(
        None,
        description="The id of the worker that posesses or posessed the most recent lock.",
    )
    topicName: Optional[str] = Field(
        None, description="The topic name of the external task."
    )
    priority: Optional[int] = Field(
        None, description="The priority of the external task."
    )
    businessKey: Optional[str] = Field(
        None,
        description="The business key of the process instance the external task belongs to.",
    )


class SortBy1(str, Enum):
    id = "id"
    lockExpirationTime = "lockExpirationTime"
    processInstanceId = "processInstanceId"
    processDefinitionId = "processDefinitionId"
    processDefinitionKey = "processDefinitionKey"
    taskPriority = "taskPriority"
    tenantId = "tenantId"


class SortOrder1(str, Enum):
    asc = "asc"
    desc = "desc"


class ExternalTaskQueryDto(BaseModel):
    externalTaskId: Optional[str] = Field(
        None, description="Filter by an external task's id."
    )
    externalTaskIdIn: Optional[List[str]] = Field(
        None, description="Filter by the comma-separated list of external task ids."
    )
    topicName: Optional[str] = Field(
        None, description="Filter by an external task topic."
    )
    workerId: Optional[str] = Field(
        None,
        description="Filter by the id of the worker that the task was most recently locked by.",
    )
    locked: Optional[bool] = Field(
        None,
        description="Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired).\nValue may only be `true`, as `false` matches any external task.",
    )
    notLocked: Optional[bool] = Field(
        None,
        description="Only include external tasks that are currently not locked (i.e., they have no lock or it has expired).\nValue may only be `true`, as `false` matches any external task.",
    )
    withRetriesLeft: Optional[bool] = Field(
        None,
        description="Only include external tasks that have a positive (&gt; 0) number of retries (or `null`). Value may only be\n`true`, as `false` matches any external task.",
    )
    noRetriesLeft: Optional[bool] = Field(
        None,
        description="Only include external tasks that have 0 retries. Value may only be `true`, as `false` matches any\nexternal task.",
    )
    lockExpirationAfter: Optional[datetime] = Field(
        None,
        description="Restrict to external tasks that have a lock that expires after a given date. By\n[default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    lockExpirationBefore: Optional[datetime] = Field(
        None,
        description="Restrict to external tasks that have a lock that expires before a given date. By\n[default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    activityId: Optional[str] = Field(
        None,
        description="Filter by the id of the activity that an external task is created for.",
    )
    activityIdIn: Optional[List[str]] = Field(
        None,
        description="Filter by the comma-separated list of ids of the activities that an external task is created for.",
    )
    executionId: Optional[str] = Field(
        None,
        description="Filter by the id of the execution that an external task belongs to.",
    )
    processInstanceId: Optional[str] = Field(
        None,
        description="Filter by the id of the process instance that an external task belongs to.",
    )
    processInstanceIdIn: Optional[List[str]] = Field(
        None,
        description="Filter by a comma-separated list of process instance ids that an external task may belong to.",
    )
    processDefinitionId: Optional[str] = Field(
        None,
        description="Filter by the id of the process definition that an external task belongs to.",
    )
    tenantIdIn: Optional[List[str]] = Field(
        None,
        description="Filter by a comma-separated list of tenant ids.\nAn external task must have one of the given tenant ids.",
    )
    active: Optional[bool] = Field(
        None,
        description="Only include active tasks. Value may only be `true`, as `false` matches any external task.",
    )
    suspended: Optional[bool] = Field(
        None,
        description="Only include suspended tasks. Value may only be `true`, as `false` matches any external task.",
    )
    priorityHigherThanOrEquals: Optional[int] = Field(
        None,
        description="Only include jobs with a priority higher than or equal to the given value.\nValue must be a valid `long` value.",
    )
    priorityLowerThanOrEquals: Optional[int] = Field(
        None,
        description="Only include jobs with a priority lower than or equal to the given value.\nValue must be a valid `long` value.",
    )
    sorting: Optional[List[SortingItem]] = Field(
        None,
        description="A JSON array of criteria to sort the result by. Each element of the array is a JSON object that\n                    specifies one ordering. The position in the array identifies the rank of an ordering, i.e., whether\n                    it is primary, secondary, etc. The ordering objects have the following properties:\n\n                    **Note:** The `sorting` properties will not be applied to the External Task count query.",
    )


class FetchExternalTaskTopicDto(BaseModel):
    topicName: str = Field(..., description="**Mandatory.** The topic's name.")
    lockDuration: int = Field(
        ...,
        description="**Mandatory.** The duration to lock the external tasks for in milliseconds.",
    )
    variables: Optional[List[str]] = Field(
        None,
        description="A JSON array of `String` values that represent variable names. For each result task belonging to this\ntopic, the given variables are returned as well if they are accessible from the external task's\nexecution. If not provided - all variables will be fetched.",
    )
    localVariables: Optional[bool] = Field(
        False, description="If `true` only local variables will be fetched."
    )
    businessKey: Optional[str] = Field(
        None,
        description="A `String` value which enables the filtering of tasks based on process instance business key.",
    )
    processDefinitionId: Optional[str] = Field(
        None, description="Filter tasks based on process definition id."
    )
    processDefinitionIdIn: Optional[List[str]] = Field(
        None, description="Filter tasks based on process definition ids."
    )
    processDefinitionKey: Optional[str] = Field(
        None, description="Filter tasks based on process definition key."
    )
    processDefinitionKeyIn: Optional[List[str]] = Field(
        None, description="Filter tasks based on process definition keys."
    )
    processDefinitionVersionTag: Optional[str] = Field(
        None, description="Filter tasks based on process definition version tag."
    )
    withoutTenantId: Optional[bool] = Field(
        False, description="Filter tasks without tenant id."
    )
    tenantIdIn: Optional[List[str]] = Field(
        None, description="Filter tasks based on tenant ids."
    )
    processVariables: Optional[Dict[str, Any]] = Field(
        None,
        description="A `JSON` object used for filtering tasks based on process instance variable values. A property name of\nthe object represents a process variable name, while the property value represents the process variable\nvalue to filter tasks by.",
    )
    deserializeValues: Optional[bool] = Field(
        False,
        description="Determines whether serializable variable values (typically variables that store custom Java objects)\nshould be deserialized on server side (default `false`).\n\nIf set to `true`, a serializable variable will be deserialized on server side and transformed to JSON\nusing [Jackson's](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note\nthat this requires the Java classes of the variable value to be on the REST API's classpath.\n\nIf set to `false`, a serializable variable will be returned in its serialized format. For example, a\nvariable that is serialized as XML will be returned as a JSON string containing XML.",
    )
    includeExtensionProperties: Optional[bool] = Field(
        False,
        description="Determines whether custom extension properties defined in the BPMN activity of the external task (e.g.\nvia the Extensions tab in the Camunda modeler) should be included in the response. Default: false",
    )


class FetchExternalTasksDto(BaseModel):
    workerId: str = Field(
        ...,
        description="**Mandatory.** The id of the worker on which behalf tasks are fetched. The returned tasks are locked for\nthat worker and can only be completed when providing the same worker id.",
    )
    maxTasks: int = Field(
        ..., description="**Mandatory.** The maximum number of tasks to return."
    )
    usePriority: Optional[bool] = Field(
        None,
        description="A `boolean` value, which indicates whether the task should be fetched based on its priority\nor arbitrarily.",
    )
    asyncResponseTimeout: Optional[int] = Field(
        None,
        description="The [Long Polling](https://docs.camunda.org/manual/latest/user-guide/process-engine/external-tasks/#long-polling-to-fetch-and-lock-external-tasks)\ntimeout in milliseconds.\n\n**Note:** The value cannot be set larger than 1.800.000 milliseconds (corresponds to 30 minutes).",
    )
    topics: Optional[List[FetchExternalTaskTopicDto]] = Field(
        None,
        description="A JSON array of topic objects for which external tasks should be fetched. The returned tasks may be\narbitrarily distributed among these topics. Each topic object has the following properties:",
    )


class FormDto(BaseModel):
    key: Optional[str] = Field(None, description="The form key.")
    contextPath: Optional[str] = Field(
        None,
        description="The context path of the process application. If the task (or the process definition) does not\nbelong to a process application deployment or a process definition at all, this\nproperty is not set.",
    )


class GroupDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the group.")
    name: Optional[str] = Field(None, description="The name of the group.")
    type: Optional[str] = Field(None, description="The type of the group.")


class SortBy2(str, Enum):
    id = "id"
    name = "name"
    type = "type"


class SortOrder2(str, Enum):
    asc = "asc"
    desc = "desc"


class GroupQueryDto(BaseModel):
    id: Optional[str] = Field(None, description="Filter by the id of the group.")
    idIn: Optional[List[str]] = Field(
        None, description="Filter by a JSON string array of group ids."
    )
    name: Optional[str] = Field(None, description="Filter by the name of the group.")
    nameLike: Optional[str] = Field(
        None, description="Filter by the name that the parameter is a substring of."
    )
    type: Optional[str] = Field(None, description="Filter by the type of the group.")
    member: Optional[str] = Field(
        None, description="Only retrieve groups where the given user id is a member of."
    )
    memberOfTenant: Optional[str] = Field(
        None, description="Only retrieve groups which are members of the given tenant."
    )
    sorting: Optional[List[SortingItem]] = Field(
        None, description="Apply sorting of the result"
    )


class HandleExternalTaskDto(BaseModel):
    workerId: Optional[str] = Field(
        None,
        description="**Mandatory.** The ID of the worker who is performing the operation on the external task.\nIf the task is already locked, must match the id of the worker who has most recently\nlocked the task.",
    )


class HistoricActivityInstanceDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the activity instance.")
    parentActivityInstanceId: Optional[str] = Field(
        None,
        description="The id of the parent activity instance, for example a sub process instance.",
    )
    activityId: Optional[str] = Field(
        None, description="The id of the activity that this object is an instance of."
    )
    activityName: Optional[str] = Field(
        None, description="The name of the activity that this object is an instance of."
    )
    activityType: Optional[str] = Field(
        None, description="The type of the activity that this object is an instance of."
    )
    processDefinitionKey: Optional[str] = Field(
        None,
        description="The key of the process definition that this activity instance belongs to.",
    )
    processDefinitionId: Optional[str] = Field(
        None,
        description="The id of the process definition that this activity instance belongs to.",
    )
    processInstanceId: Optional[str] = Field(
        None,
        description="The id of the process instance that this activity instance belongs to.",
    )
    executionId: Optional[str] = Field(
        None,
        description="The id of the execution that executed this activity instance.",
    )
    taskId: Optional[str] = Field(
        None,
        description="The id of the task that is associated to this activity instance. Is only set if the activity is a user task.",
    )
    assignee: Optional[str] = Field(
        None,
        description="The assignee of the task that is associated to this activity instance. Is only set if the activity is a user task.",
    )
    calledProcessInstanceId: Optional[str] = Field(
        None,
        description="The id of the called process instance. Is only set if the activity is a call activity and the called instance a process instance.",
    )
    calledCaseInstanceId: Optional[str] = Field(
        None,
        description="The id of the called case instance. Is only set if the activity is a call activity and the called instance a case instance.",
    )
    startTime: Optional[datetime] = Field(
        None,
        description="The time the instance was started. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/),\nthe date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    endTime: Optional[datetime] = Field(
        None,
        description="The time the instance ended. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/),\nthe date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    durationInMillis: Optional[int] = Field(
        None, description="The time the instance took to finish (in milliseconds)."
    )
    canceled: Optional[bool] = Field(
        None, description="If `true`, this activity instance is canceled."
    )
    completeScope: Optional[bool] = Field(
        None,
        description="If `true`, this activity instance did complete a BPMN 2.0 scope.",
    )
    tenantId: Optional[str] = Field(
        None, description="The tenant id of the activity instance."
    )
    removalTime: Optional[datetime] = Field(
        None,
        description="The time after which the activity instance should be removed by the History Cleanup job. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/),\nthe date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    rootProcessInstanceId: Optional[str] = Field(
        None,
        description="The process instance id of the root process instance that initiated the process containing this activity instance.",
    )


class SortBy3(str, Enum):
    activityInstanceId = "activityInstanceId"
    instanceId = "instanceId"
    executionId = "executionId"
    activityId = "activityId"
    activityName = "activityName"
    activityType = "activityType"
    startTime = "startTime"
    endTime = "endTime"
    duration = "duration"
    definitionId = "definitionId"
    occurrence = "occurrence"
    tenantId = "tenantId"


class SortOrder3(str, Enum):
    asc = "asc"
    desc = "desc"


class HistoricActivityInstanceQueryDto(BaseModel):
    activityInstanceId: Optional[str] = Field(
        None, description="Filter by activity instance id."
    )
    processInstanceId: Optional[str] = Field(
        None, description="Filter by process instance id."
    )
    processDefinitionId: Optional[str] = Field(
        None, description="Filter by process definition id."
    )
    executionId: Optional[str] = Field(
        None,
        description="Filter by the id of the execution that executed the activity instance.",
    )
    activityId: Optional[str] = Field(
        None, description="Filter by the activity id (according to BPMN 2.0 XML)."
    )
    activityName: Optional[str] = Field(
        None, description="Filter by the activity name (according to BPMN 2.0 XML)."
    )
    activityType: Optional[str] = Field(None, description="Filter by activity type.")
    taskAssignee: Optional[str] = Field(
        None,
        description="Only include activity instances that are user tasks and assigned to a given user.",
    )
    finished: Optional[bool] = Field(
        None,
        description="Only include finished activity instances.\nValue may only be `true`, as `false` behaves the same as when the property is not set.",
    )
    unfinished: Optional[bool] = Field(
        None,
        description="Only include unfinished activity instances.\nValue may only be `true`, as `false` behaves the same as when the property is not set.",
    )
    canceled: Optional[bool] = Field(
        None,
        description="Only include canceled activity instances.\nValue may only be `true`, as `false` behaves the same as when the property is not set.",
    )
    completeScope: Optional[bool] = Field(
        None,
        description="Only include activity instances which completed a scope.\nValue may only be `true`, as `false` behaves the same as when the property is not set.",
    )
    startedBefore: Optional[datetime] = Field(
        None,
        description="Restrict to instances that were started before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/),\nthe date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    startedAfter: Optional[datetime] = Field(
        None,
        description="Restrict to instances that were started after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/),\nthe date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    finishedBefore: Optional[datetime] = Field(
        None,
        description="Restrict to instances that were finished before the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/),\nthe date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    finishedAfter: Optional[datetime] = Field(
        None,
        description="Restrict to instances that were finished after the given date. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/),\nthe date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    tenantIdIn: Optional[List[str]] = Field(
        None,
        description="Must be a JSON array of Strings. An activity instance must have one of the given tenant ids.",
    )
    withoutTenantId: Optional[bool] = Field(
        None,
        description="Only include historic activity instances that belong to no tenant. Value may only be `true`, as `false` is the default behavior.",
    )
    sorting: Optional[List[SortingItem]] = Field(
        None, description="Apply sorting of the result"
    )


class State(str, Enum):
    ACTIVE = "ACTIVE"
    SUSPENDED = "SUSPENDED"
    COMPLETED = "COMPLETED"
    EXTERNALLY_TERMINATED = "EXTERNALLY_TERMINATED"
    INTERNALLY_TERMINATED = "INTERNALLY_TERMINATED"


class HistoricProcessInstanceDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the process instance.")
    rootProcessInstanceId: Optional[str] = Field(
        None,
        description="The process instance id of the root process instance that initiated the process.",
    )
    superProcessInstanceId: Optional[str] = Field(
        None, description="The id of the parent process instance, if it exists."
    )
    superCaseInstanceId: Optional[str] = Field(
        None, description="The id of the parent case instance, if it exists."
    )
    caseInstanceId: Optional[str] = Field(
        None, description="The id of the parent case instance, if it exists."
    )
    processDefinitionName: Optional[str] = Field(
        None,
        description="The name of the process definition that this process instance belongs to.",
    )
    processDefinitionKey: Optional[str] = Field(
        None,
        description="The key of the process definition that this process instance belongs to.",
    )
    processDefinitionVersion: Optional[int] = Field(
        None,
        description="The version of the process definition that this process instance belongs to.",
    )
    processDefinitionId: Optional[str] = Field(
        None,
        description="The id of the process definition that this process instance belongs to.",
    )
    businessKey: Optional[str] = Field(
        None, description="The business key of the process instance."
    )
    startTime: Optional[datetime] = Field(
        None,
        description="The time the instance was started. Default [format](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/) `yyyy-MM-dd'T'HH:mm:ss.SSSZ`.",
    )
    endTime: Optional[datetime] = Field(
        None,
        description="The time the instance ended. Default [format](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/) `yyyy-MM-dd'T'HH:mm:ss.SSSZ`.",
    )
    removalTime: Optional[datetime] = Field(
        None,
        description="The time after which the instance should be removed by the History Cleanup job. Default [format](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/) `yyyy-MM-dd'T'HH:mm:ss.SSSZ`.",
    )
    durationInMillis: Optional[int] = Field(
        None, description="The time the instance took to finish (in milliseconds)."
    )
    startUserId: Optional[str] = Field(
        None, description="The id of the user who started the process instance."
    )
    startActivityId: Optional[str] = Field(
        None,
        description="The id of the initial activity that was executed (e.g., a start event).",
    )
    deleteReason: Optional[str] = Field(
        None,
        description="The provided delete reason in case the process instance was canceled during execution.",
    )
    tenantId: Optional[str] = Field(
        None, description="The tenant id of the process instance."
    )
    state: Optional[State] = Field(
        None,
        description="Last state of the process instance, possible values are:\n\n`ACTIVE` - running process instance\n\n`SUSPENDED` - suspended process instances\n\n`COMPLETED` - completed through normal end event\n\n`EXTERNALLY_TERMINATED` - terminated externally, for instance through REST API\n\n`INTERNALLY_TERMINATED` - terminated internally, for instance by terminating boundary event",
    )


class IncidentStatus(str, Enum):
    open = "open"
    resolved = "resolved"


class SortBy4(str, Enum):
    instanceId = "instanceId"
    definitionId = "definitionId"
    definitionKey = "definitionKey"
    definitionName = "definitionName"
    definitionVersion = "definitionVersion"
    businessKey = "businessKey"
    startTime = "startTime"
    endTime = "endTime"
    duration = "duration"
    tenantId = "tenantId"


class SortOrder4(str, Enum):
    asc = "asc"
    desc = "desc"


class HistoryTimeToLiveDto(BaseModel):
    historyTimeToLive: Optional[conint(ge=0)] = Field(  # type: ignore
        None,
        description="New value for historyTimeToLive field of the definition.\nCan be `null`. Can not be negative.",
    )


class IdentityLinkDto(BaseModel):
    userId: Optional[str] = Field(
        None,
        description="The id of the user participating in this link. Either `userId` or `groupId` is set.",
    )
    groupId: Optional[str] = Field(
        None,
        description="The id of the group participating in this link. Either `groupId` or `userId` is set.",
    )
    type: str = Field(
        ...,
        description="The type of the identity link. The value of the this property can be user-defined. The Process Engine\nprovides three pre-defined Identity Link `type`s:\n\n* `candidate`\n* `assignee` - reserved for the task assignee\n* `owner` - reserved for the task owner\n\n**Note**: When adding or removing an Identity Link, the `type` property must be defined.",
    )


class IdentityServiceGroupDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the group.")
    name: Optional[str] = Field(None, description="The name of the group.")


class IdentityServiceUserDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the user.")
    firstName: Optional[str] = Field(None, description="The firstname of the user.")
    lastName: Optional[str] = Field(None, description="The lastname of the user.")
    displayName: Optional[str] = Field(
        None,
        description="The displayName is generated from the id or firstName and lastName if available.",
    )


class IncidentDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the incident.")
    processDefinitionId: Optional[str] = Field(
        None,
        description="The id of the process definition this incident is associated with.",
    )
    processInstanceId: Optional[str] = Field(
        None,
        description="The id of the process instance this incident is associated with.",
    )
    executionId: Optional[str] = Field(
        None, description="The id of the execution this incident is associated with."
    )
    incidentTimestamp: Optional[datetime] = Field(
        None,
        description="The time this incident happened. By [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/),\nthe date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    incidentType: Optional[str] = Field(
        None,
        description="The type of incident, for example: `failedJobs` will be returned in case of an incident which identified\na failed job during the execution of a process instance. See the\n[User Guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/incidents/#incident-types) for a list of incident types.",
    )
    activityId: Optional[str] = Field(
        None, description="The id of the activity this incident is associated with."
    )
    failedActivityId: Optional[str] = Field(
        None, description="The id of the activity on which the last exception occurred."
    )
    causeIncidentId: Optional[str] = Field(
        None,
        description="The id of the associated cause incident which has been triggered.",
    )
    rootCauseIncidentId: Optional[str] = Field(
        None,
        description="The id of the associated root cause incident which has been triggered.",
    )
    configuration: Optional[str] = Field(
        None, description="The payload of this incident."
    )
    tenantId: Optional[str] = Field(
        None, description="The id of the tenant this incident is associated with."
    )
    incidentMessage: Optional[str] = Field(
        None, description="The message of this incident."
    )
    jobDefinitionId: Optional[str] = Field(
        None, description="The job definition id the incident is associated with."
    )


class IncidentStatisticsResultDto(BaseModel):
    incidentType: Optional[str] = Field(
        None,
        description="The type of the incident the number of incidents is aggregated for.\nSee the [User Guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/incidents/#incident-types) for a list of incident types.",
    )
    incidentCount: Optional[int] = Field(
        None,
        description="The total number of incidents for the corresponding incident type.",
    )


class LinkableDto(BaseModel):
    links: Optional[List[AtomLink]] = Field(
        None,
        description="The links associated to this resource, with `method`, `href` and `rel`.",
    )


class LockExternalTaskDto(HandleExternalTaskDto):
    lockDuration: Optional[int] = Field(
        None,
        description="The duration to lock the external task for in milliseconds.\n**Note:** Attempting to lock an already locked external task with the same `workerId`\nwill succeed and a new lock duration will be set, starting from the current moment.",
    )


class LockedExternalTaskDto(BaseModel):
    activityId: Optional[str] = Field(
        None, description="The id of the activity that this external task belongs to."
    )
    activityInstanceId: Optional[str] = Field(
        None,
        description="The id of the activity instance that the external task belongs to.",
    )
    errorMessage: Optional[str] = Field(
        None,
        description="The full error message submitted with the latest reported failure executing this task;`null` if no failure\nwas reported previously or if no error message was submitted",
    )
    errorDetails: Optional[str] = Field(
        None,
        description="The error details submitted with the latest reported failure executing this task.`null` if no failure was\nreported previously or if no error details was submitted",
    )
    executionId: Optional[str] = Field(
        None, description="The id of the execution that the external task belongs to."
    )
    id: Optional[str] = Field(None, description="The id of the external task.")
    lockExpirationTime: Optional[datetime] = Field(
        None,
        description="The date that the task's most recent lock expires or has expired.",
    )
    processDefinitionId: Optional[str] = Field(
        None,
        description="The id of the process definition the external task is defined in.",
    )
    processDefinitionKey: Optional[str] = Field(
        None,
        description="The key of the process definition the external task is defined in.",
    )
    processDefinitionVersionTag: Optional[str] = Field(
        None,
        description="The version tag of the process definition the external task is defined in.",
    )
    processInstanceId: Optional[str] = Field(
        None, description="The id of the process instance the external task belongs to."
    )
    tenantId: Optional[str] = Field(
        None, description="The id of the tenant the external task belongs to."
    )
    retries: Optional[int] = Field(
        None, description="The number of retries the task currently has left."
    )
    suspended: Optional[bool] = Field(
        None,
        description="Whether the process instance the external task belongs to is suspended.",
    )
    workerId: Optional[str] = Field(
        None,
        description="The id of the worker that posesses or posessed the most recent lock.",
    )
    priority: Optional[int] = Field(
        None, description="The priority of the external task."
    )
    topicName: Optional[str] = Field(
        None, description="The topic name of the external task."
    )
    businessKey: Optional[str] = Field(
        None,
        description="The business key of the process instance the external task belongs to.",
    )
    variables: Optional[Dict[str, VariableValueDto]] = Field(
        None,
        description="A JSON object containing a property for each of the requested variables. The key is the variable name,\nthe value is a JSON object of serialized variable values with the following properties:",
    )


class ResultType(str, Enum):
    Execution = "Execution"
    ProcessDefinition = "ProcessDefinition"


class MetricsIntervalResultDto(BaseModel):
    timestamp: Optional[datetime] = Field(None, description="The interval timestamp.")
    name: Optional[str] = Field(None, description="The name of the metric.")
    reporter: Optional[str] = Field(
        None,
        description="The reporter of the metric. `null` if the metrics are aggregated by reporter.",
    )
    value: Optional[int] = Field(
        None, description="The value of the metric aggregated by the interval."
    )


class MetricsResultDto(BaseModel):
    result: Optional[int] = Field(
        None, description="The current sum (count) for the selected metric."
    )


class MissingAuthorizationDto(BaseModel):
    permissionName: Optional[str] = Field(
        None, description="The permission name that the user is missing."
    )
    resourceName: Optional[str] = Field(
        None,
        description="The name of the resource that the user is missing permission for.",
    )
    resourceId: Optional[str] = Field(
        None,
        description="The id of the resource that the user is missing permission for.",
    )


class MultiFormAttachmentDto(BaseModel):
    attachment_name: Optional[str] = Field(
        None, alias="attachment-name", description="The name of the attachment."
    )
    attachment_description: Optional[str] = Field(
        None,
        alias="attachment-description",
        description="The description of the attachment.",
    )
    attachment_type: Optional[str] = Field(
        None, alias="attachment-type", description="The type of the attachment."
    )
    url: Optional[str] = Field(
        None, description="The url to the remote content of the attachment."
    )
    content: Optional[bytes] = Field(None, description="The content of the attachment.")


class MultiFormDeploymentDto(BaseModel):
    tenant_id: Optional[str] = Field(
        None,
        alias="tenant-id",
        description="The tenant id for the deployment to be created.",
    )
    deployment_source: Optional[str] = Field(
        None,
        alias="deployment-source",
        description="The source for the deployment to be created.",
    )
    deploy_changed_only: Optional[bool] = Field(
        False,
        alias="deploy-changed-only",
        description="A flag indicating whether the process engine should perform duplicate checking on a per-resource basis.\nIf set to true, only those resources that have actually changed are deployed.\nChecks are made against resources included previous deployments of the same name and only against the latest versions of those resources.\nIf set to true, the option enable-duplicate-filtering is overridden and set to true.",
    )
    enable_duplicate_filtering: Optional[bool] = Field(
        False,
        alias="enable-duplicate-filtering",
        description="A flag indicating whether the process engine should perform duplicate checking for the deployment or not.\nThis allows you to check if a deployment with the same name and the same resouces already exists and\nif true, not create a new deployment but instead return the existing deployment. The default value is false.",
    )
    deployment_name: Optional[str] = Field(
        None,
        alias="deployment-name",
        description="The name for the deployment to be created.",
    )
    data: Optional[bytes] = Field(
        None,
        description="The binary data to create the deployment resource.\nIt is possible to have more than one form part with different form part names for the binary data to create a deployment.",
    )


class ValueType(str, Enum):
    Bytes = "Bytes"
    Double = "Double"
    File = "File"
    Integer = "Integer"
    String = "String"
    Boolean = "Boolean"
    Json = "Json"
    Object = "Object"


class MultiFormVariableBinaryDto(BaseModel):
    data: Optional[bytes] = Field(
        None,
        description="The binary data to be set.\nFor File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set\nOnly the filename is mandatory.",
    )
    valueType: Optional[ValueType] = Field(
        None,
        description="The name of the variable type. Either Bytes for a byte array variable or File for a file variable.",
    )


class Details(BaseModel):
    pass


class ParseExceptionDto(ExceptionDto):
    details: Optional[Dict[str, Details]] = Field(
        None,
        description="A JSON Object containing list of errors and warnings occurred during deployment.",
    )


class Parameter(BaseModel):
    pass

    class Config:
        extra = Extra.allow


class PasswordPolicyRuleDto(BaseModel):
    placeholder: Optional[str] = Field(
        None,
        description="A placeholder string that contains the name of a password policy rule.",
    )
    parameter: Optional[Dict[str, Parameter]] = Field(
        None,
        description="A map that describes the characteristics of a password policy rule, such as the minimum number of digits.",
    )


class Modifications(BaseModel):
    pass


class PatchVariablesDto(BaseModel):
    modifications: Optional[Dict[str, VariableValueDto]] = Field(
        None, description="A JSON object containing variable key-value pairs."
    )
    deletions: Optional[List[str]] = Field(
        None, description="An array of String keys of variables to be deleted."
    )


class PriorityDto(BaseModel):
    priority: Optional[int] = Field(None, description="The priority of the resource.")


class ProblemDto(BaseModel):
    message: Optional[str] = Field(None, description="The message of the problem.")
    line: Optional[int] = Field(
        None, description="The line where the problem occurred."
    )
    column: Optional[int] = Field(
        None, description="The column where the problem occurred."
    )
    mainElementId: Optional[str] = Field(
        None, description="The main element id where the problem occurred."
    )
    elementIds: Optional[List[str]] = Field(
        None, description="A list of element id affected by the problem."
    )


class ProcessDefinitionDiagramDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the process definition.")
    bpmn20Xml: Optional[str] = Field(
        None,
        description="An escaped XML string containing the XML that this definition was deployed with.\nCarriage returns, line feeds and quotation marks are escaped.",
    )


class ProcessDefinitionDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the process definition")
    key: Optional[str] = Field(
        None,
        description="The key of the process definition, i.e., the id of the BPMN 2.0 XML process definition.",
    )
    category: Optional[str] = Field(
        None, description="The category of the process definition."
    )
    description: Optional[str] = Field(
        None, description="The description of the process definition."
    )
    name: Optional[str] = Field(None, description="The name of the process definition.")
    version: Optional[int] = Field(
        None,
        description="The version of the process definition that the engine assigned to it.",
    )
    resource: Optional[str] = Field(
        None, description="The file name of the process definition."
    )
    deploymentId: Optional[str] = Field(
        None, description="The deployment id of the process definition."
    )
    diagram: Optional[str] = Field(
        None,
        description="The file name of the process definition diagram, if it exists.",
    )
    suspended: Optional[bool] = Field(
        None,
        description="A flag indicating whether the definition is suspended or not.",
    )
    tenantId: Optional[str] = Field(
        None, description="The tenant id of the process definition."
    )
    versionTag: Optional[str] = Field(
        None, description="The version tag of the process definition."
    )
    historyTimeToLive: Optional[conint(ge=0)] = Field(  # type: ignore
        None,
        description="History time to live value of the process definition.\nIs used within [History cleanup](https://docs.camunda.org/manual/latest/user-guide/process-engine/history/#history-cleanup).",
    )
    startableInTasklist: Optional[bool] = Field(
        None,
        description="A flag indicating whether the process definition is startable in Tasklist or not.",
    )


class ProcessDefinitionStatisticsResultDto(BaseModel):
    id: Optional[str] = Field(
        None,
        description="The id of the process definition the results are aggregated for.",
    )
    instances: Optional[int] = Field(
        None,
        description="The total number of running process instances of this process definition.",
    )
    failedJobs: Optional[int] = Field(
        None,
        description="The total number of failed jobs for the running instances.\n**Note**: Will be `0` (not `null`), if failed jobs were excluded.",
    )
    incidents: Optional[List[IncidentStatisticsResultDto]] = Field(
        None,
        description="Each item in the resulting array is an object which contains `incidentType` and `incidentCount`.\n**Note**: Will be an empty array, if `incidents` or `incidentsForType` were excluded.\nFurthermore, the array will be also empty if no incidents were found.",
    )
    definition: Optional[ProcessDefinitionDto] = None


class ProcessDefinitionSuspensionStateDto(BaseModel):
    suspended: Optional[bool] = Field(
        None,
        description="A `Boolean` value which indicates whether to activate or suspend all process definitions with the given key.\nWhen the value is set to `true`, all process definitions with the given key will be suspended and\nwhen the value is set to `false`, all process definitions with the given key will be activated.",
    )
    processDefinitionId: Optional[str] = Field(
        None, description="The id of the process definitions to activate or suspend."
    )
    processDefinitionKey: Optional[str] = Field(
        None, description="The key of the process definitions to activate or suspend."
    )
    includeProcessInstances: Optional[bool] = Field(
        None,
        description="A `Boolean` value which indicates whether to activate or suspend also all process instances of \nthe process definitions with the given key.\nWhen the value is set to `true`, all process instances of the process definitions with the given key\nwill be activated or suspended and when the value is set to `false`, the suspension state of \nall process instances of the process definitions with the given key will not be updated.",
    )
    executionDate: Optional[datetime] = Field(
        None,
        description="The date on which all process definitions with the given key will be activated or suspended.\nIf `null`, the suspension state of all process definitions with the given key is updated immediately.\nBy [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/),\nthe date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )


class ProcessEngineDto(BaseModel):
    name: Optional[str] = Field(None, description="The name of the process engine.")


class ProcessInstanceDto(LinkableDto):
    id: Optional[str] = Field(None, description="The id of the process instance.")
    definitionId: Optional[str] = Field(
        None,
        description="The id of the process definition that this process instance belongs to.",
    )
    businessKey: Optional[str] = Field(
        None, description="The business key of the process instance."
    )
    caseInstanceId: Optional[str] = Field(
        None,
        description="The id of the case instance associated with the process instance.",
    )
    ended: Optional[bool] = Field(
        None,
        description="A flag indicating whether the process instance has ended or not. Deprecated: will always be false!",
    )
    suspended: Optional[bool] = Field(
        None,
        description="A flag indicating whether the process instance is suspended or not.",
    )
    tenantId: Optional[str] = Field(
        None, description="The tenant id of the process instance."
    )


class Type(str, Enum):
    cancel = "cancel"
    startBeforeActivity = "startBeforeActivity"
    startAfterActivity = "startAfterActivity"
    startTransition = "startTransition"


class SortBy5(str, Enum):
    instanceId = "instanceId"
    definitionId = "definitionId"
    definitionKey = "definitionKey"
    businessKey = "businessKey"
    tenantId = "tenantId"


class SortOrder5(str, Enum):
    asc = "asc"
    desc = "desc"


class ProcessInstanceWithVariablesDto(ProcessInstanceDto):
    variables: Optional[Dict[str, VariableValueDto]] = Field(
        None, description="The id of the process instance."
    )


class RedeploymentDto(BaseModel):
    resourceIds: Optional[List[str]] = Field(
        None, description="A list of deployment resource ids to re-deploy."
    )
    resourceNames: Optional[List[str]] = Field(
        None, description="A list of deployment resource names to re-deploy."
    )
    source: Optional[str] = Field(
        None, description="Sets the source of the deployment."
    )


class ResourceOptionsDto(LinkableDto):
    pass


class ResourceReportDto(BaseModel):
    errors: Optional[List[ProblemDto]] = Field(
        None, description="A list of errors occurred during parsing."
    )
    warnings: Optional[List[ProblemDto]] = Field(
        None, description="A list of warnings occurred during parsing."
    )


class Type1(str, Enum):
    startBeforeActivity = "startBeforeActivity"
    startAfterActivity = "startAfterActivity"
    startTransition = "startTransition"


class RestartProcessInstanceModificationInstructionDto(BaseModel):
    type: Type1 = Field(
        ...,
        description="**Mandatory**. One of the following values: `startBeforeActivity`, `startAfterActivity`, `startTransition`.\n\n* A `startBeforeActivity` instruction requests to enter a given activity.\n* A `startAfterActivity` instruction requests to execute the single outgoing sequence flow of a given activity.\n* A `startTransition` instruction requests to execute a specific sequence flow.",
    )
    activityId: Optional[str] = Field(
        None,
        description="**Can be used with instructions of types** `startBeforeActivity`\nand `startAfterActivity`. Specifies the sequence flow to start.",
    )
    transitionId: Optional[str] = Field(
        None,
        description="**Can be used with instructions of types** `startTransition`.\nSpecifies the sequence flow to start.",
    )


class RetriesDto(BaseModel):
    retries: Optional[int] = Field(
        None,
        description="The number of retries to set for the resource.  Must be >= 0. If this is 0, an incident is created\nand the task, or job, cannot be fetched, or acquired anymore unless the retries are increased again.\nCan not be null.",
    )


class SchemaLogEntryDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the schema log entry.")
    timestamp: Optional[datetime] = Field(
        None, description="The date and time of the schema update."
    )
    version: Optional[str] = Field(None, description="The version of the schema.")


class SortBy6(str, Enum):
    timestamp = "timestamp"


class SortOrder6(str, Enum):
    asc = "asc"
    desc = "desc"


class SchemaLogQueryDto(BaseModel):
    version: Optional[str] = Field(None, description="The version of the schema.")
    sorting: Optional[List[SortingItem]] = Field(
        None,
        description="A JSON array of criteria to sort the result by. Each element of the array is\n                      a JSON object that specifies one ordering. The position in the array\n                      identifies the rank of an ordering, i.e., whether it is primary, secondary,\n                      etc. ",
    )


class SignalDto(BaseModel):
    name: Optional[str] = Field(
        None,
        description="The name of the signal to deliver.\n\n**Note**: This property is mandatory.",
    )
    executionId: Optional[str] = Field(
        None,
        description="Optionally specifies a single execution which is notified by the signal.\n\n**Note**: If no execution id is defined the signal is broadcasted to all subscribed\nhandlers. ",
    )
    variables: Optional[Dict[str, VariableValueDto]] = Field(
        None,
        description="A JSON object containing variable key-value pairs. Each key is a variable name and\neach value a JSON variable value object.",
    )
    tenantId: Optional[str] = Field(
        None,
        description="Specifies a tenant to deliver the signal. The signal can only be received on\nexecutions or process definitions which belongs to the given tenant.\n\n**Note**: Cannot be used in combination with executionId.",
    )
    withoutTenantId: Optional[bool] = Field(
        None,
        description="If true the signal can only be received on executions or process definitions which\nbelongs to no tenant. Value may not be false as this is the default behavior.\n\n**Note**: Cannot be used in combination with `executionId`.",
    )


class SortTaskQueryParametersDto(BaseModel):
    variable: Optional[str] = Field(
        None, description="The name of the variable to sort by."
    )
    type: Optional[str] = Field(
        None, description="The name of the type of the variable value."
    )


class StartProcessInstanceFormDto(BaseModel):
    variables: Optional[Dict[str, VariableValueDto]] = Field(None, description="")
    businessKey: Optional[str] = Field(
        None,
        description="The business key the process instance is to be initialized with.\nThe business key uniquely identifies the process instance in the context of the given process definition.",
    )


class SuspensionStateDto(BaseModel):
    suspended: Optional[bool] = Field(
        None,
        description="A Boolean value which indicates whether to activate or suspend a given instance (e.g. process instance, or batch).\nWhen the value is set to true, the given instance will be suspended and when the value is set to false,\nthe given instance will be activated.",
    )


class TaskBpmnErrorDto(BaseModel):
    errorCode: Optional[str] = Field(
        None,
        description="An error code that indicates the predefined error. It is used to identify the BPMN\nerror handler.",
    )
    errorMessage: Optional[str] = Field(
        None, description="An error message that describes the error."
    )
    variables: Optional[Dict[str, VariableValueDto]] = Field(
        None, description="A JSON object containing variable key-value pairs."
    )


class DelegationState(str, Enum):
    PENDING = "PENDING"
    RESOLVED = "RESOLVED"


class TaskDto(BaseModel):
    id: Optional[str] = Field(None, description="The task id.")
    name: Optional[str] = Field(None, description="The task name.")
    assignee: Optional[str] = Field(None, description="The assignee's id.")
    owner: Optional[str] = Field(None, description="The owner's id.")
    created: Optional[datetime] = Field(
        None,
        description="The date the task was created on.\n[Default format](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/)\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`.",
    )
    due: Optional[datetime] = Field(
        None,
        description="The task's due date.\n[Default format](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/)\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`.",
    )
    followUp: Optional[datetime] = Field(
        None,
        description="The follow-up date for the task.\n[Default format](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/)\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`.",
    )
    delegationState: Optional[DelegationState] = Field(
        None,
        description="The task's delegation state. Possible values are `PENDING` and `RESOLVED`.",
    )
    description: Optional[str] = Field(None, description="The task's description.")
    executionId: Optional[str] = Field(
        None, description="The id of the execution the task belongs to."
    )
    parentTaskId: Optional[str] = Field(
        None, description="The id the parent task, if this task is a subtask."
    )
    priority: Optional[int] = Field(None, description="The task's priority.")
    processDefinitionId: Optional[str] = Field(
        None, description="The id of the process definition the task belongs to."
    )
    processInstanceId: Optional[str] = Field(
        None, description="The id of the process instance the task belongs to."
    )
    caseExecutionId: Optional[str] = Field(
        None, description="The id of the case execution the task belongs to."
    )
    caseDefinitionId: Optional[str] = Field(
        None, description="The id of the case definition the task belongs to."
    )
    caseInstanceId: Optional[str] = Field(
        None, description="The id of the case instance the task belongs to."
    )
    taskDefinitionKey: Optional[str] = Field(None, description="The task's key.")
    suspended: Optional[bool] = Field(
        None,
        description="Whether the task belongs to a process instance that is suspended.",
    )
    formKey: Optional[str] = Field(
        None, description="If not `null`, the form key for the task."
    )
    tenantId: Optional[str] = Field(
        None, description="If not `null`, the tenant id of the task."
    )


class HistoricTaskDto(TaskDto):
    pass


class TaskEscalationDto(BaseModel):
    escalationCode: Optional[str] = Field(
        None,
        description="An escalation code that indicates the predefined escalation. It is used to identify\nthe BPMN escalation handler.",
    )
    variables: Optional[Dict[str, VariableValueDto]] = Field(
        None, description="A JSON object containing variable key-value pairs."
    )


class DelegationState1(str, Enum):
    PENDING = "PENDING"
    RESOLVED = "RESOLVED"


class SortBy7(str, Enum):
    instanceId = "instanceId"
    caseInstanceId = "caseInstanceId"
    dueDate = "dueDate"
    executionId = "executionId"
    caseExecutionId = "caseExecutionId"
    assignee = "assignee"
    created = "created"
    description = "description"
    id = "id"
    name = "name"
    nameCaseInsensitive = "nameCaseInsensitive"
    priority = "priority"
    processVariable = "processVariable"
    executionVariable = "executionVariable"
    taskVariable = "taskVariable"
    caseExecutionVariable = "caseExecutionVariable"
    caseInstanceVariable = "caseInstanceVariable"


class SortOrder7(str, Enum):
    asc = "asc"
    desc = "desc"


class TelemetryConfigurationDto(BaseModel):
    enableTelemetry: Optional[bool] = Field(
        None, description="Specifies if the telemetry data should be sent or not."
    )


class TenantDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the tenant.")
    name: Optional[str] = Field(None, description="The name of the tenant.")


class TransitionInstanceDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the transition instance.")
    parentActivityInstanceId: Optional[str] = Field(
        None,
        description="The id of the parent activity instance, for example a sub process instance.",
    )
    activityId: Optional[str] = Field(
        None,
        description="The id of the activity that this instance enters (asyncBefore job) or leaves (asyncAfter job)",
    )
    activityName: Optional[str] = Field(
        None,
        description="The name of the activity that this instance enters (asyncBefore job) or leaves (asyncAfter job)",
    )
    activityType: Optional[str] = Field(
        None,
        description="The type of the activity that this instance enters (asyncBefore job) or leaves (asyncAfter job)",
    )
    processInstanceId: Optional[str] = Field(
        None, description="The id of the process instance this instance is part of."
    )
    processDefinitionId: Optional[str] = Field(
        None, description="The id of the process definition."
    )
    executionId: Optional[str] = Field(None, description="The execution id.")
    incidentIds: Optional[List[str]] = Field(
        None, description="A list of incident ids."
    )
    incidents: Optional[List[ActivityInstanceIncidentDto]] = Field(
        None,
        description="A list of JSON objects containing incident specific properties:\n* `id`: the id of the incident\n* `activityId`: the activity id in which the incident occurred",
    )


class UserCredentialsDto(BaseModel):
    password: Optional[str] = Field(None, description="The users new password.")
    authenticatedUserPassword: Optional[str] = Field(
        None,
        description="The password of the authenticated user who changes the password of the user\n(i.e., the user with passed id as path parameter).",
    )


class UserIdDto(BaseModel):
    userId: Optional[str] = Field(
        None, description="The id of the user that the current action refers to."
    )


class UserProfileDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the user.")
    firstName: Optional[str] = Field(None, description="The first name of the user.")
    lastName: Optional[str] = Field(None, description="The first name of the user.")
    email: Optional[str] = Field(None, description="The email of the user.")


class Operator(Enum):
    eq = "eq"
    neq = "neq"
    gt = "gt"
    gteq = "gteq"
    lt = "lt"
    lteq = "lteq"
    like = "like"


class VariableQueryParameterDto(BaseModel):
    name: Optional[str] = Field(None, description="Variable name")
    operator: Optional[Operator] = Field(
        None, description="Comparison operator to be used"
    )
    value: Optional[Dict[str, Any]] = Field(
        None,
        description="The variable value, could be of type boolean, string or number",
    )


class VersionDto(BaseModel):
    version: Optional[str] = Field(None, description="The version of the Rest API.")


class ActivityInstanceDto(BaseModel):
    id: Optional[str] = Field(None, description="The id of the activity instance.")
    parentActivityInstanceId: Optional[str] = Field(
        None,
        description="The id of the parent activity instance, for example a sub process instance.",
    )
    activityId: Optional[str] = Field(None, description="The id of the activity.")
    activityName: Optional[str] = Field(None, description="The name of the activity")
    activityType: Optional[str] = Field(
        None,
        description="The type of activity (corresponds to the XML element name in the BPMN 2.0, e.g., 'userTask')",
    )
    processInstanceId: Optional[str] = Field(
        None,
        description="The id of the process instance this activity instance is part of.",
    )
    processDefinitionId: Optional[str] = Field(
        None, description="The id of the process definition."
    )
    childActivityInstances: Optional[List[ActivityInstanceDto]] = Field(
        None, description="A list of child activity instances."
    )
    childTransitionInstances: Optional[List[TransitionInstanceDto]] = Field(
        None,
        description="A list of child transition instances.\nA transition instance represents an execution waiting in an asynchronous continuation.",
    )
    executionIds: Optional[List[str]] = Field(
        None, description="A list of execution ids."
    )
    incidentIds: Optional[List[str]] = Field(
        None, description="A list of incident ids."
    )
    incidents: Optional[List[ActivityInstanceIncidentDto]] = Field(
        None,
        description="A list of JSON objects containing incident specific properties:\n* `id`: the id of the incident\n* `activityId`: the activity id in which the incident occurred",
    )


class ActivityStatisticsResultDto(BaseModel):
    id: Optional[str] = Field(
        None, description="The id of the activity the results are aggregated for."
    )
    instances: Optional[int] = Field(
        None,
        description="The total number of running process instances of this activity.",
    )
    failedJobs: Optional[int] = Field(
        None,
        description="The total number of failed jobs for the running instances.\n**Note**: Will be `0` (not `null`), if failed jobs were excluded.",
    )
    incidents: Optional[List[IncidentStatisticsResultDto]] = Field(
        None,
        description="Each item in the resulting array is an object which contains `incidentType` and `incidentCount`.\n**Note**: Will be an empty array, if `incidents` or `incidentsForType` were excluded.\nFurthermore, the array will be also empty if no incidents were found.",
    )


class AttachmentDto(LinkableDto):
    id: Optional[str] = Field(None, description="The id of the task attachment.")
    name: Optional[str] = Field(None, description="The name of the task attachment.")
    description: Optional[str] = Field(
        None, description="The description of the task attachment."
    )
    taskId: Optional[str] = Field(
        None, description="The id of the task to which the attachment belongs."
    )
    type: Optional[str] = Field(
        None,
        description="Indication of the type of content that this attachment refers to.\nCan be MIME type or any other indication.",
    )
    url: Optional[str] = Field(
        None, description="The url to the remote content of the task attachment."
    )
    createTime: Optional[datetime] = Field(
        None,
        description="The time the variable was inserted.\n[Default format](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/)\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`.",
    )
    removalTime: Optional[datetime] = Field(
        None,
        description="The time after which the attachment should be removed by the History Cleanup job.\n[Default format](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/)\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`.",
    )
    rootProcessInstanceId: Optional[str] = Field(
        None,
        description="The process instance id of the root process instance that initiated the process containing the task.",
    )


class AuthorizationExceptionDto(ExceptionDto):
    userId: Optional[str] = Field(
        None, description="The id of the user that does not have expected permissions"
    )
    missingAuthorizations: Optional[List[MissingAuthorizationDto]] = Field(
        None, description=""
    )


class CheckPasswordPolicyRuleDto(PasswordPolicyRuleDto):
    valid: Optional[bool] = Field(
        None,
        description="`true` if the password is compliant with this rule, otherwise `false`.",
    )


class CommentDto(LinkableDto):
    id: Optional[str] = Field(None, description="The id of the task comment.")
    userId: Optional[str] = Field(
        None, description="The id of the user who created the comment."
    )
    taskId: Optional[str] = Field(
        None, description="The id of the task to which the comment belongs."
    )
    time: Optional[datetime] = Field(
        None,
        description="The time when the comment was created.\n[Default format]($(docsUrl)/reference/rest/overview/date-format/)\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`.",
    )
    message: Optional[str] = Field(None, description="The content of the comment.")
    removalTime: Optional[datetime] = Field(
        None,
        description="The time after which the comment should be removed by the History Cleanup job.\n[Default format]($(docsUrl)/reference/rest/overview/date-format/)\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`.",
    )
    rootProcessInstanceId: Optional[str] = Field(
        None,
        description="The process instance id of the root process instance that initiated the process\ncontaining the task.",
    )


class CompleteExternalTaskDto(HandleExternalTaskDto):
    variables: Optional[Dict[str, VariableValueDto]] = Field(
        None,
        description="A JSON object containing variable key-value pairs. Each key is a variable name and each value a JSON variable value object with the following properties:",
    )
    localVariables: Optional[Dict[str, VariableValueDto]] = Field(
        None,
        description="A JSON object containing local variable key-value pairs. Local variables are set only in the scope of external task. Each key is a variable name and each value a JSON variable value object with the following properties:",
    )


class DeploymentDto(LinkableDto):
    id: Optional[str] = Field(None, description="The id of the deployment.")
    tenantId: Optional[str] = Field(
        None, description="The tenant id of the deployment."
    )
    deploymentTime: Optional[datetime] = Field(
        None, description="The time when the deployment was created."
    )
    source: Optional[str] = Field(None, description="The source of the deployment.")
    name: Optional[str] = Field(None, description="The name of the deployment.")


class DeploymentWithDefinitionsDto(DeploymentDto):
    deployedProcessDefinitions: Optional[Dict[str, DeployedProcessDefinitions]] = Field(
        None,
        description="A JSON Object containing a property for each of the process definitions,\nwhich are successfully deployed with that deployment.\nThe key is the process definition id, the value is a JSON Object corresponding to the process definition.",
    )
    deployedDecisionDefinitions: Optional[
        Dict[str, DeployedDecisionDefinitions]
    ] = Field(
        None,
        description="A JSON Object containing a property for each of the decision definitions,\nwhich are successfully deployed with that deployment.\nThe key is the decision definition id, the value is a JSON Object corresponding to the decision definition.",
    )
    deployedDecisionRequirementsDefinitions: Optional[
        Dict[str, DeployedDecisionRequirementsDefinitions]
    ] = Field(
        None,
        description="A JSON Object containing a property for each of the decision requirements definitions,\nwhich are successfully deployed with that deployment.\nThe key is the decision requirements definition id, the value is a JSON Object corresponding to the decision requirements definition.",
    )
    deployedCaseDefinitions: Optional[Dict[str, DeployedCaseDefinitions]] = Field(
        None,
        description="A JSON Object containing a property for each of the case definitions,\nwhich are successfully deployed with that deployment.\nThe key is the case definition id, the value is a JSON Object corresponding to the case definition.",
    )


class ExtendLockOnExternalTaskDto(HandleExternalTaskDto):
    newDuration: Optional[int] = Field(
        None,
        description="An amount of time (in milliseconds). This is the new lock duration starting from the\ncurrent moment.",
    )


class ExternalTaskBpmnError(TaskBpmnErrorDto):
    workerId: Optional[str] = Field(
        None,
        description="The id of the worker that reports the failure. Must match the id of the worker who has most recently\nlocked the task.",
    )


class ExternalTaskFailureDto(HandleExternalTaskDto):
    errorMessage: Optional[str] = Field(
        None, description="An message indicating the reason of the failure."
    )
    errorDetails: Optional[str] = Field(
        None, description="A detailed error description."
    )
    retries: Optional[int] = Field(
        None,
        description="A number of how often the task should be retried. Must be >= 0. If this is 0, an incident is created and\nthe task cannot be fetched anymore unless the retries are increased again. The incident's message is set\nto the `errorMessage` parameter.",
    )
    retryTimeout: Optional[int] = Field(
        None,
        description="A timeout in milliseconds before the external task becomes available again for fetching. Must be >= 0.",
    )


class HistoricProcessInstanceQueryDto(BaseModel):
    processInstanceId: Optional[str] = Field(
        None, description="Filter by process instance id."
    )
    processInstanceIds: Optional[List[str]] = Field(
        None,
        description="Filter by process instance ids. Must be a JSON array of `Strings`.",
    )
    processDefinitionId: Optional[str] = Field(
        None, description="Filter by the process definition the instances run on."
    )
    processDefinitionKey: Optional[str] = Field(
        None,
        description="Filter by the key of the process definition the instances run on.",
    )
    processDefinitionKeyIn: Optional[List[str]] = Field(
        None,
        description="Filter by a list of process definition keys. A process instance must have one of the given process definition keys. Must be a JSON array of `Strings`.",
    )
    processDefinitionName: Optional[str] = Field(
        None,
        description="Filter by the name of the process definition the instances run on.",
    )
    processDefinitionNameLike: Optional[str] = Field(
        None,
        description="Filter by process definition names that the parameter is a substring of.",
    )
    processDefinitionKeyNotIn: Optional[List[str]] = Field(
        None,
        description="Exclude instances that belong to a set of process definitions. Must be a JSON array of `Strings`.",
    )
    processInstanceBusinessKey: Optional[str] = Field(
        None, description="Filter by process instance business key."
    )
    processInstanceBusinessKeyLike: Optional[str] = Field(
        None,
        description="Filter by process instance business key that the parameter is a substring of.",
    )
    rootProcessInstances: Optional[bool] = Field(
        None,
        description="Restrict the query to all process instances that are top level process instances.",
    )
    finished: Optional[bool] = Field(
        None,
        description="Only include finished process instances. This flag includes all process instances\nthat are completed or terminated. Value may only be `true`, as `false` is the default behavior.",
    )
    unfinished: Optional[bool] = Field(
        None,
        description="Only include unfinished process instances. Value may only be `true`, as `false` is the default behavior.",
    )
    withIncidents: Optional[bool] = Field(
        None,
        description="Only include process instances which have an incident. Value may only be `true`, as `false` is the default behavior.",
    )
    withRootIncidents: Optional[bool] = Field(
        None,
        description="Only include process instances which have a root incident. Value may only be `true`, as `false` is the default behavior.",
    )
    incidentType: Optional[str] = Field(
        None,
        description="Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/incidents/#incident-types) for a list of incident types.",
    )
    incidentStatus: Optional[IncidentStatus] = Field(
        None,
        description="Only include process instances which have an incident in status either open or resolved. To get all process instances, use the query parameter withIncidents.",
    )
    incidentMessage: Optional[str] = Field(
        None, description="Filter by the incident message. Exact match."
    )
    incidentMessageLike: Optional[str] = Field(
        None,
        description="Filter by the incident message that the parameter is a substring of.",
    )
    startedBefore: Optional[datetime] = Field(
        None,
        description="Restrict to instances that were started before the given date.\nBy [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    startedAfter: Optional[datetime] = Field(
        None,
        description="Restrict to instances that were started after the given date.\nBy [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    finishedBefore: Optional[datetime] = Field(
        None,
        description="Restrict to instances that were finished before the given date.\nBy [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    finishedAfter: Optional[datetime] = Field(
        None,
        description="Restrict to instances that were finished after the given date.\nBy [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    executedActivityAfter: Optional[datetime] = Field(
        None,
        description="Restrict to instances that executed an activity after the given date (inclusive).\nBy [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    executedActivityBefore: Optional[datetime] = Field(
        None,
        description="Restrict to instances that executed an activity before the given date (inclusive).\nBy [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    executedJobAfter: Optional[datetime] = Field(
        None,
        description="Restrict to instances that executed an job after the given date (inclusive).\nBy [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    executedJobBefore: Optional[datetime] = Field(
        None,
        description="Restrict to instances that executed an job before the given date (inclusive).\nBy [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    startedBy: Optional[str] = Field(
        None,
        description="Only include process instances that were started by the given user.",
    )
    superProcessInstanceId: Optional[str] = Field(
        None,
        description="Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.",
    )
    subProcessInstanceId: Optional[str] = Field(
        None,
        description="Restrict query to one process instance that has a sub process instance with the given id.",
    )
    superCaseInstanceId: Optional[str] = Field(
        None,
        description="Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.",
    )
    subCaseInstanceId: Optional[str] = Field(
        None,
        description="Restrict query to one process instance that has a sub case instance with the given id.",
    )
    caseInstanceId: Optional[str] = Field(
        None,
        description="Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.",
    )
    tenantIdIn: Optional[List[str]] = Field(
        None,
        description="Filter by a list of tenant ids. A process instance must have one of the given tenant ids. Must be a JSON array of `Strings`",
    )
    withoutTenantId: Optional[bool] = Field(
        None,
        description="Only include historic process instances which belong to no tenant. Value may only be `true`, as `false` is the default behavior.",
    )
    executedActivityIdIn: Optional[List[str]] = Field(
        None,
        description="Restrict to instances that executed an activity with one of given ids. Must be a JSON array of `Strings`",
    )
    activeActivityIdIn: Optional[List[str]] = Field(
        None,
        description="Restrict to instances that have an active activity with one of given ids. Must be a JSON array of `Strings`",
    )
    active: Optional[bool] = Field(
        None, description="Restrict to instances that are active."
    )
    suspended: Optional[bool] = Field(
        None, description="Restrict to instances that are suspended."
    )
    completed: Optional[bool] = Field(
        None, description="Restrict to instances that are completed."
    )
    externallyTerminated: Optional[bool] = Field(
        None, description="Restrict to instances that are externallyTerminated."
    )
    internallyTerminated: Optional[bool] = Field(
        None, description="Restrict to instances that are internallyTerminated."
    )
    variables: Optional[List[VariableQueryParameterDto]] = Field(
        None,
        description="A JSON array to only include process instances that have/had variables with certain values.\nThe array consists of objects with the three properties `name`, `operator` and `value`. `name` (`String`) is the variable name,\n`operator` (`String`) is the comparison operator to be used and `value` the variable value.\n\nValue may be `String`, `Number` or `Boolean`.\n\nValid operator values are: `eq` - equal to; `neq` - not equal to; `gt` - greater than; `gteq` - greater than or equal to; `lt` - lower than; `lteq` - lower than or equal to; `like`.\n",
    )
    variableNamesIgnoreCase: Optional[bool] = Field(
        None,
        description="Match all variable names provided in variables case-insensitively. If set to `true` variableName and variablename are treated as equal.",
    )
    variableValuesIgnoreCase: Optional[bool] = Field(
        None,
        description="Match all variable values provided in variables case-insensitively. If set to `true` variableValue and variablevalue are treated as equal.",
    )
    orQueries: Optional[List[HistoricProcessInstanceQueryDto]] = Field(
        None,
        description="A JSON array of nested historic process instance queries with OR semantics.\n\nA process instance matches a nested query if it fulfills at least one of the query's predicates.\n\nWith multiple nested queries, a process instance must fulfill at least one predicate of each query\n([Conjunctive Normal Form](https://en.wikipedia.org/wiki/Conjunctive_normal_form)).\n\nAll process instance query properties can be used except for: `sorting`\n\nSee the [User Guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries.",
    )
    sorting: Optional[List[SortingItem]] = Field(
        None, description="Apply sorting of the result"
    )


class IdentityServiceGroupInfoDto(BaseModel):
    groups: Optional[List[IdentityServiceGroupDto]] = Field(
        None, description="An array of group objects."
    )
    groupUsers: Optional[List[IdentityServiceUserDto]] = Field(
        None,
        description="An array that contains all users that are member in one of the groups.",
    )


class MessageCorrelationResultWithVariableDto(BaseModel):
    resultType: Optional[ResultType] = Field(
        None,
        description="Indicates if the message was correlated to a message start event or an \nintermediate message catching event. In the first case, the resultType is \n`ProcessDefinition` and otherwise `Execution`.",
    )
    processInstance: Optional[ProcessInstanceDto] = None
    execution: Optional[ExecutionDto] = None
    variables: Optional[Dict[str, VariableValueDto]] = Field(
        None,
        description="This property is returned if the `variablesInResultEnabled` is set to `true`.\nContains a list of the process variables. ",
    )


class PasswordPolicyDto(BaseModel):
    rules: Optional[List[PasswordPolicyRuleDto]] = Field(
        None,
        description="An array of password policy rules. Each element of the array is representing one rule of the policy.",
    )


class PasswordPolicyRequestDto(BaseModel):
    password: Optional[str] = Field(
        None,
        description="The candidate password to be check against the password policy.",
    )
    profile: Optional[UserProfileDto] = None


class ProcessInstanceQueryDto(BaseModel):
    deploymentId: Optional[str] = Field(
        None, description="Filter by the deployment the id belongs to."
    )
    processDefinitionId: Optional[str] = Field(
        None, description="Filter by the process definition the instances run on."
    )
    processDefinitionKey: Optional[str] = Field(
        None,
        description="Filter by the key of the process definition the instances run on.",
    )
    processDefinitionKeyIn: Optional[List[str]] = Field(
        None,
        description="Filter by a list of process definition keys.\nA process instance must have one of the given process definition keys. Must be a JSON array of Strings.",
    )
    processDefinitionKeyNotIn: Optional[List[str]] = Field(
        None,
        description="Exclude instances by a list of process definition keys.\nA process instance must not have one of the given process definition keys. Must be a JSON array of Strings.",
    )
    businessKey: Optional[str] = Field(
        None, description="Filter by process instance business key."
    )
    businessKeyLike: Optional[str] = Field(
        None,
        description="Filter by process instance business key that the parameter is a substring of.",
    )
    caseInstanceId: Optional[str] = Field(
        None, description="Filter by case instance id."
    )
    superProcessInstance: Optional[str] = Field(
        None,
        description="Restrict query to all process instances that are sub process instances of the given process instance.\nTakes a process instance id.",
    )
    subProcessInstance: Optional[str] = Field(
        None,
        description="Restrict query to all process instances that have the given process instance as a sub process instance.\nTakes a process instance id.",
    )
    superCaseInstance: Optional[str] = Field(
        None,
        description="Restrict query to all process instances that are sub process instances of the given case instance.\nTakes a case instance id.",
    )
    subCaseInstance: Optional[str] = Field(
        None,
        description="Restrict query to all process instances that have the given case instance as a sub case instance.\nTakes a case instance id.",
    )
    active: Optional[bool] = Field(
        None,
        description="Only include active process instances. Value may only be true, as false is the default behavior.",
    )
    suspended: Optional[bool] = Field(
        None,
        description="Only include suspended process instances. Value may only be true, as false is the default behavior.",
    )
    processInstanceIds: Optional[List[str]] = Field(
        None,
        description="Filter by a list of process instance ids. Must be a JSON array of Strings.",
    )
    withIncident: Optional[bool] = Field(
        None,
        description="Filter by presence of incidents. Selects only process instances that have an incident.",
    )
    incidentId: Optional[str] = Field(None, description="Filter by the incident id.")
    incidentType: Optional[str] = Field(
        None,
        description="Filter by the incident type. See the User Guide for a list of incident types.",
    )
    incidentMessage: Optional[str] = Field(
        None, description="Filter by the incident message. Exact match."
    )
    incidentMessageLike: Optional[str] = Field(
        None,
        description="Filter by the incident message that the parameter is a substring of.",
    )
    tenantIdIn: Optional[List[str]] = Field(
        None,
        description="Filter by a list of tenant ids. A process instance must have one of the given tenant ids.\nMust be a JSON array of Strings.",
    )
    withoutTenantId: Optional[bool] = Field(
        None,
        description="Only include process instances which belong to no tenant.\nValue may only be true, as false is the default behavior.",
    )
    processDefinitionWithoutTenantId: Optional[bool] = Field(
        None,
        description="Only include process instances which process definition has no tenant id.",
    )
    activityIdIn: Optional[List[str]] = Field(
        None,
        description="Filter by a list of activity ids.\nA process instance must currently wait in a leaf activity with one of the given activity ids.",
    )
    rootProcessInstances: Optional[bool] = Field(
        None,
        description="Restrict the query to all process instances that are top level process instances.",
    )
    leafProcessInstances: Optional[bool] = Field(
        None,
        description="Restrict the query to all process instances that are leaf instances. (i.e. don't have any sub instances)",
    )
    variables: Optional[List[VariableQueryParameterDto]] = Field(
        None,
        description="A JSON array to only include process instances that have variables with certain values.\nThe array consists of objects with the three properties `name`, `operator` and `value`.\n`name` (String) is the variable name,\n`operator` (String) is the comparison operator to be used and `value` the variable value.\nThe `value` may be String, Number or Boolean.\n\nValid operator values are: `eq` - equal to; `neq` - not equal to; `gt` - greater than;\n`gteq` - greater than or equal to; `lt` - lower than; `lteq` - lower than or equal to; `like`.",
    )
    variableNamesIgnoreCase: Optional[bool] = Field(
        None,
        description="Match all variable names in this query case-insensitively.\nIf set to true variableName and variablename are treated as equal.",
    )
    variableValuesIgnoreCase: Optional[bool] = Field(
        None,
        description="Match all variable values in this query case-insensitively.\nIf set to true variableValue and variablevalue are treated as equal.",
    )
    orQueries: Optional[List[ProcessInstanceQueryDto]] = Field(
        None,
        description="A JSON array of nested process instance queries with OR semantics.\nA process instance matches a nested query if it fulfills at least one of the query's predicates.\nWith multiple nested queries, a process instance must fulfill at least one predicate of each query (Conjunctive Normal Form).\nAll process instance query properties can be used except for: `sorting`\nSee the [User guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries.",
    )
    sorting: Optional[List[SortingItem]] = Field(
        None, description="Apply sorting of the result"
    )


class ProcessInstanceSuspensionStateAsyncDto(SuspensionStateDto):
    processInstanceIds: Optional[List[str]] = Field(
        None,
        description="A list of process instance ids which defines a group of process instances\nwhich will be activated or suspended by the operation.",
    )
    processInstanceQuery: Optional[ProcessInstanceQueryDto] = None
    historicProcessInstanceQuery: Optional[HistoricProcessInstanceQueryDto] = None


class ProcessInstanceSuspensionStateDto(SuspensionStateDto):
    processDefinitionId: Optional[str] = Field(
        None,
        description="The process definition id of the process instances to activate or suspend.\n\n**Note**: This parameter can be used only with combination of `suspended`.",
    )
    processDefinitionKey: Optional[str] = Field(
        None,
        description="The process definition key of the process instances to activate or suspend.\n\n**Note**: This parameter can be used only with combination of `suspended`, `processDefinitionTenantId`, and `processDefinitionWithoutTenantId`.",
    )
    processDefinitionTenantId: Optional[str] = Field(
        None,
        description="Only activate or suspend process instances of a process definition which belongs to a tenant with the given id.\n\n**Note**: This parameter can be used only with combination of `suspended`, `processDefinitionKey`, and `processDefinitionWithoutTenantId`.",
    )
    processDefinitionWithoutTenantId: Optional[bool] = Field(
        None,
        description="Only activate or suspend process instances of a process definition which belongs to no tenant.\nValue may only be true, as false is the default behavior.\n\n**Note**: This parameter can be used only with combination of `suspended`, `processDefinitionKey`, and `processDefinitionTenantId`.",
    )
    processInstanceIds: Optional[List[str]] = Field(
        None,
        description="A list of process instance ids which defines a group of process instances\nwhich will be activated or suspended by the operation.\n\n**Note**: This parameter can be used only with combination of `suspended`, `processInstanceQuery`, and `historicProcessInstanceQuery`.",
    )
    processInstanceQuery: Optional[ProcessInstanceQueryDto] = None
    historicProcessInstanceQuery: Optional[HistoricProcessInstanceQueryDto] = None


class RestartProcessInstanceDto(BaseModel):
    processInstanceIds: Optional[List[str]] = Field(
        None, description="A list of process instance ids to restart."
    )
    historicProcessInstanceQuery: Optional[HistoricProcessInstanceQueryDto] = None
    skipCustomListeners: Optional[bool] = Field(
        None,
        description="Skip execution listener invocation for activities that are started as part of this request.",
    )
    skipIoMappings: Optional[bool] = Field(
        None,
        description="Skip execution of\n[input/output variable mappings](https://docs.camunda.org/manual/latest/user-guide/process-engine/variables/#input-output-variable-mapping)\nfor activities that are started as part of this request.",
    )
    initialVariables: Optional[bool] = Field(
        None,
        description="Set the initial set of variables during restart. By default, the last set of variables is used.",
    )
    withoutBusinessKey: Optional[bool] = Field(
        None,
        description="Do not take over the business key of the historic process instance.",
    )
    instructions: Optional[
        List[RestartProcessInstanceModificationInstructionDto]
    ] = Field(
        None,
        description="**Optional**. A JSON array of instructions that specify which activities to start the process instance at.\nIf this property is omitted, the process instance starts at its default blank start event.",
    )


class SetJobRetriesByProcessDto(BaseModel):
    processInstances: Optional[List[str]] = Field(
        None,
        description="A list of process instance ids to fetch jobs, for which retries will be set.",
    )
    retries: Optional[conint(ge=0)] = Field(  # type: ignore
        None,
        description="An integer representing the number of retries. Please note that the value cannot be negative or null.",
    )
    processInstanceQuery: Optional[ProcessInstanceQueryDto] = None
    historicProcessInstanceQuery: Optional[HistoricProcessInstanceQueryDto] = None


class SetRemovalTimeToHistoricProcessInstancesDto(AbstractSetRemovalTimeDto):
    historicProcessInstanceIds: Optional[List[str]] = Field(
        None, description="The id of the process instance."
    )
    historicProcessInstanceQuery: Optional[HistoricProcessInstanceQueryDto] = None
    hierarchical: Optional[bool] = Field(
        None,
        description="Sets the removal time to all historic process instances in the hierarchy.\nValue may only be `true`, as `false` is the default behavior.",
    )


class SetRetriesForExternalTasksDto(BaseModel):
    retries: Optional[int] = Field(
        None,
        description="The number of retries to set for the external task.  Must be >= 0. If this is 0, an incident is created\nand the task cannot be fetched anymore unless the retries are increased again. Can not be null.",
    )
    externalTaskIds: Optional[List[str]] = Field(
        None,
        description="The ids of the external tasks to set the number of retries for.",
    )
    processInstanceIds: Optional[List[str]] = Field(
        None,
        description="The ids of process instances containing the tasks to set the number of retries for.",
    )
    externalTaskQuery: Optional[ExternalTaskQueryDto] = None
    processInstanceQuery: Optional[ProcessInstanceQueryDto] = None
    historicProcessInstanceQuery: Optional[HistoricProcessInstanceQueryDto] = None


class SetVariablesAsyncDto(BaseModel):
    processInstanceIds: Optional[List[str]] = Field(
        None,
        description="A list of process instance ids that define a group of process instances\nto which the operation will set variables.\n\nPlease note that if `processInstanceIds`, `processInstanceQuery` and `historicProcessInstanceQuery`\nare defined, the resulting operation will be performed on the union of these sets.",
    )
    processInstanceQuery: Optional[ProcessInstanceQueryDto] = None
    historicProcessInstanceQuery: Optional[HistoricProcessInstanceQueryDto] = None
    variables: Optional[Dict[str, VariableValueDto]] = Field(
        None,
        description="A variables the operation will set in the root scope of the process instances.",
    )


class TaskQueryDto(BaseModel):
    processInstanceId: Optional[str] = Field(
        None,
        description="Restrict to tasks that belong to process instances with the given id.",
    )
    processInstanceIdIn: Optional[List[str]] = Field(
        None,
        description="Restrict to tasks that belong to process instances with the given ids.",
    )
    processInstanceBusinessKey: Optional[str] = Field(
        None,
        description="Restrict to tasks that belong to process instances with the given business key.",
    )
    processInstanceBusinessKeyExpression: Optional[str] = Field(
        None,
        description="Restrict to tasks that belong to process instances with the given business key which \nis described by an expression. See the \n[user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions.",
    )
    processInstanceBusinessKeyIn: Optional[List[str]] = Field(
        None,
        description="Restrict to tasks that belong to process instances with one of the give business keys. \nThe keys need to be in a comma-separated list.",
    )
    processInstanceBusinessKeyLike: Optional[str] = Field(
        None,
        description="Restrict to tasks that have a process instance business key that has the parameter \nvalue as a substring.",
    )
    processInstanceBusinessKeyLikeExpression: Optional[str] = Field(
        None,
        description="Restrict to tasks that have a process instance business key that has the parameter \nvalue as a substring and is described by an expression. See the\n[user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) \nfor more information on available functions.",
    )
    processDefinitionId: Optional[str] = Field(
        None,
        description="Restrict to tasks that belong to a process definition with the given id.",
    )
    processDefinitionKey: Optional[str] = Field(
        None,
        description="Restrict to tasks that belong to a process definition with the given key.",
    )
    processDefinitionKeyIn: Optional[List[str]] = Field(
        None,
        description="Restrict to tasks that belong to a process definition with one of the given keys. The \nkeys need to be in a comma-separated list.",
    )
    processDefinitionName: Optional[str] = Field(
        None,
        description="Restrict to tasks that belong to a process definition with the given name.",
    )
    processDefinitionNameLike: Optional[str] = Field(
        None,
        description="Restrict to tasks that have a process definition name that has the parameter value as \na substring.",
    )
    executionId: Optional[str] = Field(
        None,
        description="Restrict to tasks that belong to an execution with the given id.",
    )
    caseInstanceId: Optional[str] = Field(
        None,
        description="Restrict to tasks that belong to case instances with the given id.",
    )
    caseInstanceBusinessKey: Optional[str] = Field(
        None,
        description="Restrict to tasks that belong to case instances with the given business key.",
    )
    caseInstanceBusinessKeyLike: Optional[str] = Field(
        None,
        description="Restrict to tasks that have a case instance business key that has the parameter value \nas a substring.",
    )
    caseDefinitionId: Optional[str] = Field(
        None,
        description="Restrict to tasks that belong to a case definition with the given id.",
    )
    caseDefinitionKey: Optional[str] = Field(
        None,
        description="Restrict to tasks that belong to a case definition with the given key.",
    )
    caseDefinitionName: Optional[str] = Field(
        None,
        description="Restrict to tasks that belong to a case definition with the given name.",
    )
    caseDefinitionNameLike: Optional[str] = Field(
        None,
        description="Restrict to tasks that have a case definition name that has the parameter value as a \nsubstring.",
    )
    caseExecutionId: Optional[str] = Field(
        None,
        description="Restrict to tasks that belong to a case execution with the given id.",
    )
    activityInstanceIdIn: Optional[List[str]] = Field(
        None,
        description="Only include tasks which belong to one of the passed and comma-separated activity \ninstance ids.",
    )
    tenantIdIn: Optional[List[str]] = Field(
        None,
        description="Only include tasks which belong to one of the passed and comma-separated \ntenant ids.",
    )
    withoutTenantId: Optional[bool] = Field(
        False,
        description="Only include tasks which belong to no tenant. Value may only be `true`, \nas `false` is the default behavior.",
    )
    assignee: Optional[str] = Field(
        None, description="Restrict to tasks that the given user is assigned to."
    )
    assigneeExpression: Optional[str] = Field(
        None,
        description="Restrict to tasks that the user described by the given expression is assigned to. See the\n[user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) \nfor more information on available functions.",
    )
    assigneeLike: Optional[str] = Field(
        None,
        description="Restrict to tasks that have an assignee that has the parameter \nvalue as a substring.",
    )
    assigneeLikeExpression: Optional[str] = Field(
        None,
        description="Restrict to tasks that have an assignee that has the parameter value described by the \ngiven expression as a substring. See the \n[user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) \nfor more information on available functions.",
    )
    assigneeIn: Optional[List[str]] = Field(
        None,
        description="Only include tasks which are assigned to one of the passed and comma-separated user ids.",
    )
    owner: Optional[str] = Field(
        None, description="Restrict to tasks that the given user owns."
    )
    ownerExpression: Optional[str] = Field(
        None,
        description="Restrict to tasks that the user described by the given expression owns. See the \n[user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) \nfor more information on available functions.",
    )
    candidateGroup: Optional[str] = Field(
        None, description="Only include tasks that are offered to the given group."
    )
    candidateGroupExpression: Optional[str] = Field(
        None,
        description="Only include tasks that are offered to the group described by the given expression. \nSee the \n[user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) \nfor more information on available functions.",
    )
    candidateUser: Optional[str] = Field(
        None,
        description="Only include tasks that are offered to the given user or to one of his groups.",
    )
    candidateUserExpression: Optional[str] = Field(
        None,
        description="Only include tasks that are offered to the user described by the given expression. \nSee the \n[user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions) \nfor more information on available functions.",
    )
    includeAssignedTasks: Optional[bool] = Field(
        False,
        description="Also include tasks that are assigned to users in candidate queries. Default is to only \ninclude tasks that are not assigned to any user if you query by candidate user or\ngroup(s).",
    )
    involvedUser: Optional[str] = Field(
        None,
        description="Only include tasks that the given user is involved in. A user is involved in a task if \nan identity link exists between task and user (e.g., the user is the assignee).",
    )
    involvedUserExpression: Optional[str] = Field(
        None,
        description="Only include tasks that the user described by the given expression is involved in.\nA user is involved in a task if an identity link exists between task and user\n(e.g., the user is the assignee). See the\n[user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions.",
    )
    assigned: Optional[bool] = Field(
        False,
        description="If set to `true`, restricts the query to all tasks that are assigned.",
    )
    unassigned: Optional[bool] = Field(
        False,
        description="If set to `true`, restricts the query to all tasks that are unassigned.",
    )
    taskDefinitionKey: Optional[str] = Field(
        None, description="Restrict to tasks that have the given key."
    )
    taskDefinitionKeyIn: Optional[List[str]] = Field(
        None,
        description="Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.",
    )
    taskDefinitionKeyLike: Optional[str] = Field(
        None,
        description="Restrict to tasks that have a key that has the parameter value as a substring.",
    )
    name: Optional[str] = Field(
        None, description="Restrict to tasks that have the given name."
    )
    nameNotEqual: Optional[str] = Field(
        None, description="Restrict to tasks that do not have the given name."
    )
    nameLike: Optional[str] = Field(
        None,
        description="Restrict to tasks that have a name with the given parameter value as substring.",
    )
    nameNotLike: Optional[str] = Field(
        None,
        description="Restrict to tasks that do not have a name with the given parameter\nvalue as substring.",
    )
    description: Optional[str] = Field(
        None, description="Restrict to tasks that have the given description."
    )
    descriptionLike: Optional[str] = Field(
        None,
        description="Restrict to tasks that have a description that has the parameter\nvalue as a substring.",
    )
    priority: Optional[int] = Field(
        None, description="Restrict to tasks that have the given priority."
    )
    maxPriority: Optional[int] = Field(
        None, description="Restrict to tasks that have a lower or equal priority."
    )
    minPriority: Optional[int] = Field(
        None, description="Restrict to tasks that have a higher or equal priority."
    )
    dueDate: Optional[datetime] = Field(
        None,
        description="Restrict to tasks that are due on the given date. By\n[default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have the format\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.546+0200`.",
    )
    dueDateExpression: Optional[str] = Field(
        None,
        description="Restrict to tasks that are due on the date described by the given expression. See the\n[user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.",
    )
    dueAfter: Optional[datetime] = Field(
        None,
        description="Restrict to tasks that are due after the given date. By\n[default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have\nthe format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.435+0200`.",
    )
    dueAfterExpression: Optional[str] = Field(
        None,
        description="Restrict to tasks that are due after the date described by the given expression.\nSee the\n[user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.",
    )
    dueBefore: Optional[datetime] = Field(
        None,
        description="Restrict to tasks that are due before the given date. By\n[default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have\nthe format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.243+0200`.",
    )
    dueBeforeExpression: Optional[str] = Field(
        None,
        description="Restrict to tasks that are due before the date described by the given expression.\nSee the\n[user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.",
    )
    followUpDate: Optional[datetime] = Field(
        None,
        description="Restrict to tasks that have a followUp date on the given date. By\n[default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date\nmust have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.342+0200`.",
    )
    followUpDateExpression: Optional[str] = Field(
        None,
        description="Restrict to tasks that have a followUp date on the date described by the given\nexpression. See the\n[user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.",
    )
    followUpAfter: Optional[datetime] = Field(
        None,
        description="Restrict to tasks that have a followUp date after the given date. By\n[default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have\nthe format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.542+0200`.",
    )
    followUpAfterExpression: Optional[str] = Field(
        None,
        description="Restrict to tasks that have a followUp date after the date described by the given\nexpression. See the\n[user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.",
    )
    followUpBefore: Optional[str] = Field(
        None,
        description="Restrict to tasks that have a followUp date before the given date. By\n[default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have\nthe format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.234+0200`.",
    )
    followUpBeforeExpression: Optional[str] = Field(
        None,
        description="Restrict to tasks that have a followUp date before the date described by the given\nexpression. See the\n[user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.",
    )
    followUpBeforeOrNotExistent: Optional[datetime] = Field(
        None,
        description="Restrict to tasks that have no followUp date or a followUp date before the given date.\nBy [default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have\nthe format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.432+0200`. The typical use case\nis to query all `active` tasks for a user for a given date.",
    )
    followUpBeforeOrNotExistentExpression: Optional[str] = Field(
        None,
        description="Restrict to tasks that have no followUp date or a followUp date before the date\ndescribed by the given expression. See the\n[user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.",
    )
    createdOn: Optional[datetime] = Field(
        None,
        description="Restrict to tasks that were created on the given date. By\n[default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must have\nthe format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.324+0200`.",
    )
    createdOnExpression: Optional[str] = Field(
        None,
        description="Restrict to tasks that were created on the date described by the given expression.\nSee the\n[user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.",
    )
    createdAfter: Optional[datetime] = Field(
        None,
        description="Restrict to tasks that were created after the given date. By\n[default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must\nhave the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.342+0200`.",
    )
    createdAfterExpression: Optional[str] = Field(
        None,
        description="Restrict to tasks that were created after the date described by the given expression.\nSee the\n[user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.",
    )
    createdBefore: Optional[datetime] = Field(
        None,
        description="Restrict to tasks that were created before the given date. By\n[default](https://docs.camunda.org/manual/latest/reference/rest/overview/date-format/), the date must\nhave the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.332+0200`.",
    )
    createdBeforeExpression: Optional[str] = Field(
        None,
        description="Restrict to tasks that were created before the date described by the given expression.\nSee the\n[user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.",
    )
    delegationState: Optional[DelegationState1] = Field(
        None,
        description="Restrict to tasks that are in the given delegation state. Valid values are\n`PENDING` and `RESOLVED`.",
    )
    candidateGroups: Optional[List[str]] = Field(
        None,
        description="Restrict to tasks that are offered to any of the given candidate groups. Takes a\ncomma-separated list of group names, so for example\n`developers,support,sales`.",
    )
    candidateGroupsExpression: Optional[str] = Field(
        None,
        description="Restrict to tasks that are offered to any of the candidate groups described by the\ngiven expression. See the\n[user guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to\n`java.util.List` of Strings.",
    )
    withCandidateGroups: Optional[bool] = Field(
        False,
        description="Only include tasks which have a candidate group. Value may only be `true`,\nas `false` is the default behavior.",
    )
    withoutCandidateGroups: Optional[bool] = Field(
        False,
        description="Only include tasks which have no candidate group. Value may only be `true`,\nas `false` is the default behavior.",
    )
    withCandidateUsers: Optional[bool] = Field(
        False,
        description="Only include tasks which have a candidate user. Value may only be `true`,\nas `false` is the default behavior.",
    )
    withoutCandidateUsers: Optional[bool] = Field(
        False,
        description="Only include tasks which have no candidate users. Value may only be `true`,\nas `false` is the default behavior.",
    )
    active: Optional[bool] = Field(
        False,
        description="Only include active tasks. Value may only be `true`, as `false`\nis the default behavior.",
    )
    suspended: Optional[bool] = Field(
        False,
        description="Only include suspended tasks. Value may only be `true`, as\n`false` is the default behavior.",
    )
    taskVariables: Optional[List[VariableQueryParameterDto]] = Field(
        None,
        description="A JSON array to only include tasks that have variables with certain values. The\narray consists of JSON objects with three properties `name`, `operator` and `value`.\n`name` is the variable name, `operator` is the comparison operator to be used and\n`value` the variable value. `value` may be of type `String`, `Number` or `Boolean`.\n\nValid `operator` values are:\n`eq` - equal to;\n`neq` - not equal to;\n`gt` - greater than;\n`gteq` - greater than or equal to;\n`lt` - lower than;\n`lteq` - lower than or equal to;\n`like`.\n`key` and `value` may not contain underscore or comma characters.",
    )
    processVariables: Optional[List[VariableQueryParameterDto]] = Field(
        None,
        description="A JSON array to only include tasks that belong to a process instance with variables\nwith certain values. The array consists of JSON objects with three properties\n`name`, `operator` and `value`. `name` is the variable name, `operator` is the\ncomparison operator to be used and `value` the variable value. `value` may be of\ntype `String`, `Number` or `Boolean`.\n\nValid `operator` values are:\n`eq` - equal to;\n`neq` - not equal to;\n`gt` - greater than;\n`gteq` - greater than or equal to;\n`lt` - lower than;\n`lteq` - lower than or equal to;\n`like`.\n`key` and `value` may not contain underscore or comma characters.",
    )
    caseInstanceVariables: Optional[List[VariableQueryParameterDto]] = Field(
        None,
        description="A JSON array to only include tasks that belong to a case instance with variables\nwith certain values. The array consists of JSON objects with three properties\n`name`, `operator` and `value`. `name` is the variable name, `operator` is the\ncomparison operator to be used and `value` the variable value. `value` may be of\ntype `String`, `Number` or `Boolean`.\n\nValid `operator` values are:\n`eq` - equal to;\n`neq` - not equal to;\n`gt` - greater than;\n`gteq` - greater than or equal to;\n`lt` - lower than;\n`lteq` - lower than or equal to;\n`like`.\n`key` and `value` may not contain underscore or comma characters.",
    )
    variableNamesIgnoreCase: Optional[bool] = Field(
        False,
        description="Match all variable names in this query case-insensitively. If set\n`variableName` and `variablename` are treated as equal.",
    )
    variableValuesIgnoreCase: Optional[bool] = Field(
        False,
        description="Match all variable values in this query case-insensitively. If set\n`variableValue` and `variablevalue` are treated as equal.",
    )
    parentTaskId: Optional[str] = Field(
        None,
        description="Restrict query to all tasks that are sub tasks of the given task. Takes a task id.",
    )
    orQueries: Optional[List[TaskQueryDto]] = Field(
        None,
        description="A JSON array of nested task queries with OR semantics. A task matches a nested query if it fulfills\n*at least one* of the query's predicates. With multiple nested queries, a task must fulfill at least one predicate of *each* query ([Conjunctive Normal Form](https://en.wikipedia.org/wiki/Conjunctive_normal_form)).\n\nAll task query properties can be used except for: `sorting`, `withCandidateGroups`,\n`withoutCandidateGroups`, `withCandidateUsers`, `withoutCandidateUsers`\n\nSee the [User guide](https://docs.camunda.org/manual/latest/user-guide/process-engine/process-engine-api/#or-queries)\nfor more information about OR queries.",
    )
    sorting: Optional[List[SortingItem]] = Field(
        None, description="Apply sorting of the result"
    )


class TriggerVariableValueDto(VariableValueDto):
    local: Optional[bool] = Field(
        None,
        description="Indicates whether the variable should be a local variable or not.\nIf set to true, the variable becomes a local variable of the execution\nentering the target activity.",
    )


class UserDto(BaseModel):
    profile: Optional[UserProfileDto] = None
    credentials: Optional[UserCredentialsDto] = None


class CheckPasswordPolicyResultDto(PasswordPolicyDto):
    valid: Optional[bool] = Field(
        None,
        description="`true` if the password is compliant with the policy, otherwise `false`.",
    )


class DeleteHistoricProcessInstancesDto(BaseModel):
    historicProcessInstanceIds: Optional[List[str]] = Field(
        None, description="A list historic process instance ids to delete."
    )
    historicProcessInstanceQuery: Optional[HistoricProcessInstanceQueryDto] = None
    deleteReason: Optional[str] = Field(
        None, description="A string with delete reason."
    )
    failIfNotExists: Optional[bool] = Field(
        None,
        description="If set to `false`, the request will still be successful if one ore more of the process ids are not found.",
    )


class DeleteProcessInstancesDto(BaseModel):
    processInstanceIds: Optional[List[str]] = Field(
        None, description="A list process instance ids to delete."
    )
    deleteReason: Optional[str] = Field(
        None, description="A string with delete reason."
    )
    skipCustomListeners: Optional[bool] = Field(
        None,
        description="Skip execution listener invocation for activities that are started or ended as part of this request.",
    )
    skipSubprocesses: Optional[bool] = Field(
        None,
        description="Skip deletion of the subprocesses related to deleted processes as part of this request.",
    )
    processInstanceQuery: Optional[ProcessInstanceQueryDto] = None
    historicProcessInstanceQuery: Optional[HistoricProcessInstanceQueryDto] = None


class ProcessInstanceModificationInstructionDto(BaseModel):
    type: Type = Field(
        ...,
        description="**Mandatory**. One of the following values: `cancel`, `startBeforeActivity`, `startAfterActivity`, `startTransition`.\n\n* A cancel instruction requests cancellation of a single activity instance or all instances of one activity.\n* A startBeforeActivity instruction requests to enter a given activity.\n* A startAfterActivity instruction requests to execute the single outgoing sequence flow of a given activity.\n* A startTransition instruction requests to execute a specific sequence flow.",
    )
    variables: Optional[TriggerVariableValueDto] = None
    activityId: Optional[str] = Field(
        None,
        description="Can be used with instructions of types `startTransition`. Specifies the sequence flow to start.",
    )
    transitionId: Optional[str] = Field(
        None,
        description="Can be used with instructions of types `startTransition`. Specifies the sequence flow to start.",
    )
    activityInstanceId: Optional[str] = Field(
        None,
        description="Can be used with instructions of type `cancel`. Specifies the activity instance to cancel.\nValid values are the activity instance IDs supplied by the [Get Activity Instance request](https://docs.camunda.org/manual/latest/reference/rest/process-instance/get-activity-instances/).",
    )
    transitionInstanceId: Optional[str] = Field(
        None,
        description="Can be used with instructions of type `cancel`. Specifies the transition instance to cancel.\nValid values are the transition instance IDs supplied by the [Get Activity Instance request](https://docs.camunda.org/manual/latest/reference/rest/process-instance/get-activity-instances/).",
    )
    ancestorActivityInstanceId: Optional[str] = Field(
        None,
        description="Can be used with instructions of type `startBeforeActivity`, `startAfterActivity`, and `startTransition`.\nValid values are the activity instance IDs supplied by the Get Activity Instance request.\nIf there are multiple parent activity instances of the targeted activity,\nthis specifies the ancestor scope in which hierarchy the activity/transition is to be instantiated.\n\nExample: When there are two instances of a subprocess and an activity contained in the subprocess is to be started,\nthis parameter allows to specifiy under which subprocess instance the activity should be started.",
    )
    cancelCurrentActiveActivityInstances: Optional[bool] = Field(
        None,
        description="Can be used with instructions of type cancel. Prevents the deletion of new created activity instances.",
    )


class StartProcessInstanceDto(BaseModel):
    businessKey: Optional[str] = Field(
        None, description="The business key of the process instance."
    )
    variables: Optional[Dict[str, VariableValueDto]] = Field(None, description="")
    caseInstanceId: Optional[str] = Field(
        None,
        description="The case instance id the process instance is to be initialized with.",
    )
    startInstructions: Optional[
        List[ProcessInstanceModificationInstructionDto]
    ] = Field(
        None,
        description="**Optional**. A JSON array of instructions that specify which activities to start the process instance at.\nIf this property is omitted, the process instance starts at its default blank start event.",
    )
    skipCustomListeners: Optional[bool] = Field(
        None,
        description="Skip execution listener invocation for activities that are started or ended as part of this request.\n**Note**: This option is currently only respected when start instructions are submitted\nvia the `startInstructions` property.",
    )
    skipIoMappings: Optional[bool] = Field(
        None,
        description="Skip execution of\n[input/output variable mappings](https://docs.camunda.org/manual/latest/user-guide/process-engine/variables/#input-output-variable-mapping)\nfor activities that are started or ended as part of this request.\n**Note**: This option is currently only respected when start instructions are submitted\nvia the `startInstructions` property.",
    )
    withVariablesInReturn: Optional[bool] = Field(
        None,
        description="Indicates if the variables, which was used by the process instance during execution, should be returned.\nDefault value: `false`",
    )


class ProcessInstanceModificationDto(BaseModel):
    skipCustomListeners: Optional[bool] = Field(
        None,
        description="Skip execution listener invocation for activities that are started or ended as part of this request.",
    )
    skipIoMappings: Optional[bool] = Field(
        None,
        description="Skip execution of [input/output variable mappings](https://docs.camunda.org/manual/latest/user-guide/process-engine/variables/#input-output-variable-mapping)\nfor activities that are started or ended as part of this request.",
    )
    instructions: Optional[List[ProcessInstanceModificationInstructionDto]] = Field(
        None,
        description="JSON array of modification instructions. The instructions are executed in the order they are in.",
    )
    annotation: Optional[str] = Field(
        None,
        description="An arbitrary text annotation set by a user for auditing reasons.",
    )


ActivityInstanceDto.update_forward_refs()
HistoricProcessInstanceQueryDto.update_forward_refs()
ProcessInstanceQueryDto.update_forward_refs()
TaskQueryDto.update_forward_refs()
